<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Add.html">
<link rel="next" href="Rac.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Add" rel="Chapter" href="Add.html">
<link title="Sorting" rel="Chapter" href="Sorting.html">
<link title="Rac" rel="Chapter" href="Rac.html">
<link title="Cordic" rel="Chapter" href="Cordic.html">
<link title="Prefix" rel="Chapter" href="Prefix.html">
<link title="Mul" rel="Chapter" href="Mul.html">
<link title="Lfsr" rel="Chapter" href="Lfsr.html"><link title="Design" rel="Section" href="#2_Design">
<link title="data path" rel="Subsection" href="#3_datapath">
<link title="Sorting network implementation" rel="Subsection" href="#3_Sortingnetworkimplementation">
<title>Sorting</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Add.html" title="Add">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Rac.html" title="Rac">Next</a>
</div>
<h1>Module <a href="type_Sorting.html">Sorting</a></h1>

<pre><span class="keyword">module</span> Sorting: <code class="code">sig</code> <a href="Sorting.html">..</a> <code class="code">end</code></pre><div class="info module top">
<h2 id="2_Sortingnetworks">Sorting networks</h2> 
<p>

  A sorting network arranges a fixed configuration of compare/swap
  operations to sort data.  The static nature of the network means
  they can be easily implemented in hardware.
<p>

  This module implements <code class="code">Bitonic</code> and <code class="code">Odd-Even merge</code> sort networks.
<p>

  The actual data to be sorted, and low level compare swap operations
  are seperated from the network itself allowing various configurations
<p>
<ul>
<li>sort lists of integers</li>
<li><code class="code">Bits</code> or <code class="code">Signals</code> combinatorial networks</li>
<li>pipelined</li>
<li>configure the sorts direction (invert the compare operation)</li>
<li>sort arbirary data according to some key</li>
</ul>

  <h4 id="4_Ideanumberofelementstosort">Idea; number of elements to sort</h4>
<p>

  The network structure requires the number of elements to sort is
  a power of two.
<p>

  An easy way to get round this limitiation is pad an arbitrary
  length list with the maximum value to the nearest power of 2 length,
  then drop these values from the output (since they always will be 
  sorted to the top of the list).  Because these values are then
  unreferenced a portion of the network will get removed automatically.
<p>

  That said a potentially large number of internal nodes will still be
  left behind and we know something about them - they are bigger than
  all the other values being sorted.  We could therefore encode
  this into the data being sorted with an option data type where none 
  represents a value bigger than all others;
<p>

<pre class="codepre"><code class="code">  type t = data_type option
</code></pre>
<p>

  and a compare function
<p>

<pre class="codepre"><code class="code">  let compare_swap dir a b = 
    match dir, a, b with
    | _, None, None -&gt; a,b
    | Up, None, Some d | _, Some d, None -&gt; Some d, None
    | Down, None, Some d | _, Some d, None -&gt; None, Some d
    | .... (* and so on *)
</code></pre>
<p>

  It would be very interesting to see if this could evaluate an optimal sorting
  network.<br>
</div>
<hr width="100%">
<br>
<h3 id="3_datapath">data path</h3><br>

<pre><span id="TYPEdirn"><span class="keyword">type</span> <code class="type"></code>dirn</span> </pre>
<div class="info ">
internal sorting direction<br>
</div>


<pre><span class="keyword">module type</span> <a href="Sorting.Swap.html">Swap</a> = <code class="code">sig</code> <a href="Sorting.Swap.html">..</a> <code class="code">end</code></pre><div class="info">
A <code class="code">Swap</code> module defines the datapath of the sorting network.
</div>

<pre><span class="keyword">module</span> <a href="Sorting.SwapInt.html">SwapInt</a>: <code class="type"><a href="Sorting.Swap.html">Swap</a></code><code class="type">  with type t = int</code></pre><div class="info">
Sort lists of integers
</div>

<pre><span class="keyword">module</span> <a href="Sorting.SwapHw.html">SwapHw</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">B</code><code class="code"> : </code><code class="type">HardCaml.Comb.S</code><code class="code">) -&gt; </code><code class="type"><a href="Sorting.Swap.html">Swap</a></code><code class="type">  with type t = B.t</code></div></pre><div class="info">
Sort in hardware (<code class="code">Bits</code> or <code class="code">Signals</code>)
</div>

<pre><span class="keyword">module</span> <a href="Sorting.SwapReg.html">SwapReg</a>: <code class="type"><a href="Sorting.Swap.html">Swap</a></code><code class="type">  with type t = HardCaml.Signal.Comb.t</code></pre><div class="info">
Pipelined sort
</div>
<br>
<h3 id="3_Sortingnetworkimplementation">Sorting network implementation</h3><br>

<pre><span class="keyword">module type</span> <a href="Sorting.Sort.html">Sort</a> = <code class="code">sig</code> <a href="Sorting.Sort.html">..</a> <code class="code">end</code></pre><div class="info">
A sorting network
</div>

<pre><span class="keyword">module</span> <a href="Sorting.Bitonic.html">Bitonic</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">S</code><code class="code"> : </code><code class="type"><a href="Sorting.Swap.html">Swap</a></code><code class="code">) -&gt; </code><code class="type"><a href="Sorting.Sort.html">Sort</a></code><code class="type">  with type t = S.t</code></div></pre><div class="info">
Bitonic sort
</div>

<pre><span class="keyword">module</span> <a href="Sorting.OddEvenMerge.html">OddEvenMerge</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">S</code><code class="code"> : </code><code class="type"><a href="Sorting.Swap.html">Swap</a></code><code class="code">) -&gt; </code><code class="type"><a href="Sorting.Sort.html">Sort</a></code><code class="type">  with type t = S.t</code></div></pre><div class="info">
Odd-even merge sort
</div>
<br>
<h2 id="2_Design">Design</h2><br>

<pre><span class="keyword">module</span> <a href="Sorting.Design.html">Design</a>: <code class="type">HardCamlFramework.Framework.Design</code><code class="type"> </code></pre></body></html>