<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Float (gg.Gg.Float)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/></head><body><div class="odoc-doc"><a href="../index.html">Up</a><div class="intro"><h1><span class="keyword">Module </span><a href="../#/Float">Float</a></h1></div><div class="mod"><div class="def"><span class="keyword">module </span>Float : <span class="keyword">sig</span> ... <span class="keyword">end</span></div><div class="doc">Floating point number utilities.<br/>This module defines a few useful constants,
functions, comparisons on floating point numbers. The printers
output a lossless textual representation of floats.<br/>floatrecall on OCaml's floating
point representation.</div><hr/><div><div class="region" id="/t.typ"><a href="#/t.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>t = float</div><div class="doc">The type for floating point numbers.</div></div></div><div class="doc"><h1 id="constants">Constants</h1></div><div class="region" id="/e.val"><a href="#/e.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>e : float</div><div class="doc">The constant <a href="http://mathworld.wolfram.com/e.html">e</a>.</div></div></div><div class="region" id="/pi.val"><a href="#/pi.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>pi : float</div><div class="doc">The constant <a href="http://mathworld.wolfram.com/Pi.html">pi</a>.</div></div></div><div class="region" id="/two_pi.val"><a href="#/two_pi.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>two_pi : float</div><div class="doc"><code>2 *. pi</code></div></div></div><div class="region" id="/pi_div_2.val"><a href="#/pi_div_2.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>pi_div_2 : float</div><div class="doc"><code>pi /. 2</code>.</div></div></div><div class="region" id="/pi_div_4.val"><a href="#/pi_div_4.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>pi_div_4 : float</div><div class="doc"><code>pi /. 4</code>.</div></div></div><div class="region" id="/inv_pi.val"><a href="#/inv_pi.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>inv_pi : float</div><div class="doc"><code>1 /. pi</code>.</div></div></div><div class="region" id="/max_sub_float.val"><a href="#/max_sub_float.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>max_sub_float : float</div><div class="doc">The greatest positive subnormal floating point number.</div></div></div><div class="region" id="/min_sub_float.val"><a href="#/min_sub_float.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>min_sub_float : float</div><div class="doc">The smallest positive subnormal floating point number.</div></div></div><div class="region" id="/max_frac_float.val"><a href="#/max_frac_float.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>max_frac_float : float</div><div class="doc">The greatest positive floating point number with a fractional
part (the <code>float</code> before 2<sup>52</sup>). Any number outside
[<code>-max_frac_float;max_frac_float</code>] is an integer.</div></div></div><div class="region" id="/max_int_arith.val"><a href="#/max_int_arith.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>max_int_arith : float</div><div class="doc">The greatest positive floating point number (2<sup>53</sup>) such that
any <span style="font-style: italic">integer</span> in the range
[<code>-max_int_arith;max_int_arith</code>] is represented exactly.
Integer arithmetic can be performed exactly in this interval.</div></div></div><div class="doc"><h1 id="functions">Functions</h1><br/><span style="font-weight: bold">Note.</span> If applicable, a function taking NaNs returns a NaN
unless otherwise specified.</div><div class="region" id="/deg_of_rad.val"><a href="#/deg_of_rad.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>deg_of_rad : float -&gt; float</div><div class="doc"><code>deg_of_rad r</code> is <code>r</code>
<a href="http://mathworld.wolfram.com/Radian.html">radians</a> in
<a href="http://mathworld.wolfram.com/Degree.html">degrees</a>.</div></div></div><div class="region" id="/rad_of_deg.val"><a href="#/rad_of_deg.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>rad_of_deg : float -&gt; float</div><div class="doc"><code>rad_of_deg d</code> is <code>d</code>
<a href="http://mathworld.wolfram.com/Degree.html">degrees</a> in
<a href="http://mathworld.wolfram.com/Radian.html">radians</a>.</div></div></div><div class="region" id="/wrap_angle.val"><a href="#/wrap_angle.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>wrap_angle : float -&gt; float</div><div class="doc"><code>wrap_angle r</code> is the angle <code>r</code> in the interval [<code>-pi;pi</code>[.</div></div></div><div class="region" id="/random.val"><a href="#/random.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>random : ?min:float -&gt; len:float -&gt; unit -&gt; float</div><div class="doc"><code>random min len ()</code> is a random float in the interval
[<code>min;min+len</code>] (<code>min</code> defaults to 0.). Uses the standard
library's default <code>Random</code> state for the generation.<br/><span style="font-weight: bold">Warning.</span> The float generated by a given state may
change in future versions of the library.</div></div></div><div class="region" id="/srandom.val"><a href="#/srandom.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>srandom : <a href="../../../ocaml/Random/State/index.html#/t.typ">Random.State.t</a> -&gt; ?min:float -&gt; len:float -&gt; unit -&gt; float</div><div class="doc"><code>srandom state min len ()</code> is like random but uses <code>state</code>
for the generation.<br/><span style="font-weight: bold">Warning.</span> The float generated by a given <code>state</code> may
change in future versions of the library.</div></div></div><div class="region" id="/mix.val"><a href="#/mix.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>mix : float -&gt; float -&gt; float -&gt; float</div><div class="doc"><code>mix x y t</code> is the linear interpolation <code>x +. t *. (y -. x)</code>.</div></div></div><div class="region" id="/step.val"><a href="#/step.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>step : float -&gt; float -&gt; float</div><div class="doc"><code>step edge x</code> is <code>0.</code> if <code>x &lt; edge</code> and <code>1.</code> otherwise. The
result is undefined on NaNs.</div></div></div><div class="region" id="/smooth_step.val"><a href="#/smooth_step.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>smooth_step : float -&gt; float -&gt; float -&gt; float</div><div class="doc"><code>smooth_step e0 e1 x</code> is <code>0.</code> if <code>x &lt;= e0</code>, <code>1.</code> if <code>x &gt;= e1</code>
and cubic hermite interpolation between 0. and 1. otherwise. The
result is undefined on NaNs.</div></div></div><div class="region" id="/fmax.val"><a href="#/fmax.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>fmax : float -&gt; float -&gt; float</div><div class="doc"><code>fmax x y</code> is <code>y</code> if <code>x &lt; y</code> and <code>x</code> otherwise. If <code>x</code> or <code>y</code> is
NaN returns the other argument. If both are NaNs returns NaN.</div></div></div><div class="region" id="/fmin.val"><a href="#/fmin.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>fmin : float -&gt; float -&gt; float</div><div class="doc"><code>fmin x y</code> is <code>x</code> if <code>x &lt; y</code> and <code>y</code> otherwise. If <code>x</code> or <code>y</code> is
NaN returns the other argument. If both are NaNs returns NaN.</div></div></div><div class="region" id="/clamp.val"><a href="#/clamp.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>clamp : min:float -&gt; max:float -&gt; float -&gt; float</div><div class="doc"><code>clamp min max x</code> is <code>min</code> if <code>x &lt; min</code>, <code>max</code> if <code>x &gt; max</code> and
<code>x</code> otherwise. The result is undefined on NaNs and if <code>min &gt;
      max</code>.</div></div></div><div class="region" id="/remap.val"><a href="#/remap.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>remap : x0:float -&gt; x1:float -&gt; y0:float -&gt; y1:float -&gt; float -&gt; float</div><div class="doc"><code>remap x0 x1 y0 y1 v</code> applies to <code>v</code> the
<a href="http://mathworld.wolfram.com/AffineTransformation.html">affine
transform</a> that maps <code>x0</code> to <code>y0</code> and <code>x1</code> to <code>y1</code>. If the
transform is undefined (<code>x0 = x1</code> and <code>y0 &lt;&gt; y1</code>) the function
returns <code>y0</code> for any <code>v</code>.</div></div></div><div class="region" id="/round.val"><a href="#/round.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>round : float -&gt; float</div><div class="doc"><code>round x</code> is the integer nearest to <code>x</code>. Ties are rounded
towards positive infinity. If <code>x</code> is an infinity, returns <code>x</code>.<br/><span style="font-weight: bold">Note.</span> If the absolute magnitude of <code>x</code> is an integer strictly
greater than max_frac_float, <code>round x = x</code> may be <code>false</code>.</div></div></div><div class="region" id="/int_of_round.val"><a href="#/int_of_round.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>int_of_round : float -&gt; int</div><div class="doc"><code>int_of_round x</code> is <code>truncate (round v)</code>. The result is
undefined on NaNs and infinities.</div></div></div><div class="region" id="/round_dfrac.val"><a href="#/round_dfrac.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>round_dfrac : int -&gt; float -&gt; float</div><div class="doc"><code>round_dfrac d x</code> rounds <code>x</code> to the <code>d</code>th <span style="font-style: italic">decimal</span> fractional
digit. Ties are rounded towards positive infinity. If <code>x</code> is an
infinity, returns <code>x</code>. The result is only defined for <code>0 &lt;= d &lt;=
      16</code>.</div></div></div><div class="region" id="/round_dsig.val"><a href="#/round_dsig.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>round_dsig : int -&gt; float -&gt; float</div><div class="doc"><code>round_dsig d x</code> rounds the normalized <span style="font-style: italic">decimal</span> significand
of <code>x</code> to the <code>d</code>th decimal fractional digit. Ties are rounded
towards positive infinity. The result is NaN on infinities. The
result only defined for <code>0 &lt;= d &lt;= 16</code>.<br/><span style="font-weight: bold">Warning.</span> The current implementation overflows on large <code>x</code>
and <code>d</code>.</div></div></div><div class="region" id="/round_zero.val"><a href="#/round_zero.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>round_zero : eps:float -&gt; float -&gt; float</div><div class="doc"><code>round_zero eps x</code> is <code>0.</code> if <code>abs_float x &lt; eps</code> and <code>x</code> otherwise.
The result is undefined if <code>eps</code> is NaN.</div></div></div><div class="region" id="/chop.val"><a href="#/chop.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>chop : eps:float -&gt; float -&gt; float</div><div class="doc"><code>chop eps x</code> is <code>round x</code> if <code>abs_float (x -. round x) &lt; eps</code> and <code>x</code>
otherwise. The result is undefined if <code>eps</code> is NaN.</div></div></div><div class="region" id="/sign.val"><a href="#/sign.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>sign : float -&gt; float</div><div class="doc"><code>sign x</code> is <code>1.</code> if <code>x &gt; 0.</code>, <code>0.</code> if <code>x = 0.</code>, <code>-1.</code> if <code>x &lt; 0.</code></div></div></div><div class="region" id="/sign_bit.val"><a href="#/sign_bit.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>sign_bit : float -&gt; bool</div><div class="doc"><code>sign_bit x</code> is <code>true</code> iff the sign bit is set in <code>x</code>.</div></div></div><div class="region" id="/succ.val"><a href="#/succ.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>succ : float -&gt; float</div><div class="doc"><code>succ x</code> is the floating point value just after <code>x</code> towards positive
infinity. Returns in particular :
<ul><li>NaN on NaNs.</li><li><code>infinity</code> on <code>infinity</code>.</li><li><code>-max_float</code> on <code>neg_infinity</code>.</li><li><code>min_sub_float</code> on <code>0.</code> <span style="font-weight: bold">or</span> <code>-0.</code>.</li></ul></div></div></div><div class="region" id="/pred.val"><a href="#/pred.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>pred : float -&gt; float</div><div class="doc"><code>pred x</code> is <code>-. succ (-.x)</code>, i.e. the floating point value before
<code>x</code> towards negative infinity.</div></div></div><div class="region" id="/nan.val"><a href="#/nan.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>nan : int -&gt; float</div><div class="doc"><code>nan payload</code> is a NaN whose 51 lower significand bits are
defined by the 51 lower (or less, as <code>int</code> allows) bits of
<code>payload</code>.</div></div></div><div class="region" id="/nan_payload.val"><a href="#/nan_payload.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>nan_payload : float -&gt; int</div><div class="doc"><code>nan_payload x</code> is the 51 lower significand bits (or less, as
<code>int</code> allows) of the NaN <code>x</code>.</div></div></div><div class="doc"><h1 id="comparisons">Predicates and comparisons</h1></div><div class="region" id="/is_zero.val"><a href="#/is_zero.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>is_zero : eps:float -&gt; float -&gt; bool</div><div class="doc"><code>is_zero eps x</code> is <code>true</code> if <code>abs_float x &lt; eps</code>
and <code>false</code> otherwise. The result is undefined if <code>eps</code> is NaN.</div></div></div><div class="region" id="/is_nan.val"><a href="#/is_nan.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>is_nan : float -&gt; bool</div><div class="doc"><code>is_nan x</code> is <code>true</code> iff <code>x</code> is a NaN.</div></div></div><div class="region" id="/is_inf.val"><a href="#/is_inf.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>is_inf : float -&gt; bool</div><div class="doc"><code>is_inf x</code> is <code>true</code> iff <code>x</code> is <code>infinity</code> or <code>neg_infinity</code>.</div></div></div><div class="region" id="/is_int.val"><a href="#/is_int.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>is_int : float -&gt; bool</div><div class="doc"><code>is_int x</code> is <code>true</code> iff <code>x</code> is an integer.</div></div></div><div class="region" id="/equal.val"><a href="#/equal.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>equal : float -&gt; float -&gt; bool</div><div class="doc"><code>equal x y</code> is <code>x = y</code>.</div></div></div><div class="region" id="/equal_tol.val"><a href="#/equal_tol.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>equal_tol : eps:float -&gt; float -&gt; float -&gt; bool</div><div class="doc"><code>equal_tol eps x y</code> is <code>true</code> iff |<code>x - y</code>| &lt;= <code>eps</code> * max
(1,|<code>x</code>|,|<code>y</code>|). On special values the function behaves like
<code>compare x y = 0</code>. The condition turns into an absolute tolerance
test for small magnitudes and a relative tolerance test for
large magnitudes.</div></div></div><div class="region" id="/compare.val"><a href="#/compare.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>compare : float -&gt; float -&gt; int</div><div class="doc"><code>compare x y</code> is <code>Pervasives.compare x y</code>.</div></div></div><div class="region" id="/compare_tol.val"><a href="#/compare_tol.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>compare_tol : eps:float -&gt; float -&gt; float -&gt; int</div><div class="doc"><code>compare_tol ~eps x y</code> is <code>0</code> iff <code>equal_tol ~eps x y</code> is <code>true</code>
and <code>Pervasives.compare x y</code> otherwise.</div></div></div><div class="doc"><h1 id="printers">Printers</h1></div><div class="region" id="/pp.val"><a href="#/pp.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>pp : <a href="../../../ocaml/Format/index.html#/formatter.typ">Format.formatter</a> -&gt; float -&gt; unit</div><div class="doc"><code>pp ppf x</code> prints a lossless textual representation of <code>x</code> on <code>ppf</code>.<br/><ul><li>Normals are represented by <code>&quot;[-]0x1.&lt;f&gt;p&lt;e&gt;&quot;</code> where
<code>&lt;f&gt;</code> is the significand bits in hexadecimal and <code>&lt;e&gt;</code> the
unbiased exponent in decimal.</li><li>Subnormals are represented by <code>&quot;[-]0x0.&lt;f&gt;p-1022&quot;</code> where
<code>&lt;f&gt;</code> is the significand bits in hexadecimal.</li><li>NaNs are represented by <code>&quot;[-]nan(0x&lt;p&gt;)&quot;</code> where <code>&lt;p&gt;</code> is the payload
in hexadecimal.</li><li>Infinities and zeroes are represented by <code>&quot;[-]inf&quot;</code> and <code>&quot;[-]0.&quot;</code>.</li></ul><br/>This format should be compatible with recent implementations of
<a href="http://www.opengroup.org/onlinepubs/000095399/functions/strtod.html">strtod</a> and hence with <code>float_of_string</code> (but negative NaNs seem to
be problematic to get back).</div></div></div><div class="doc"><h1 id="floatrecall">Quick recall on OCaml's <code>float</code>s</h1><br/>An OCaml <code>float</code> is an
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE-754</a>
64 bit double precision binary floating point number. The 64 bits
are laid out as follows :
<pre>
+----------------+-----------------------+-------------------------+
| sign s (1 bit) | exponent e (11 bits)  | significand t (52 bits) |
+----------------+-----------------------+-------------------------+
               63|62                   52|51                      0|
</pre><br/>The value represented depends on s, e and t :
<pre>
sign   exponent       significand   value represented           meaning
-------------------------------------------------------------------------
s      0              0             -1^s * 0                    zero
s      0              t &lt;&gt; 0        -1^s * 0.t * 2^-1022        subnormal
s      0 &lt; e &lt; 2047   f             -1^s * 1.t * 2^(e - 1023)   normal
s      2047           0             -1^s * infinity             infinity
s      2047           t &lt;&gt; 0        NaN                         not a number
</pre><br/>There are two zeros, a positive and a negative one but both are
deemed equal by <code>=</code> and <code>Pervasives.compare</code>. A NaN is never equal
(=) to <span style="font-style: italic">itself</span> or to another NaN however <code>Pervasives.compare</code>
asserts any NaN to be equal to itself and to any other NaN.<br/>The bit layout of a <code>float</code> can be converted to an <code>int64</code> and
back using <code>Int64.bits_of_float</code> and <code>Int64.float_of_bits</code>.<br/>The bit 51 of a NaN is used to distinguish between quiet (bit set)
and signaling NaNs (bit cleared); the remaining 51 lower bits of
the significand are the NaN's <span style="font-style: italic">payload</span> which can be used to
store diagnostic information. These features don't seem to used in
OCaml.<br/>The significand of a floating point number is made of 53 binary
digits (don't forget the implicit digit), this corresponds to
log<sub>10</sub>(2<sup>53</sup>) ~ 16 <span style="font-style: italic">decimal</span> digits.<br/>Only <code>float</code> values in the interval ]<code>-2</code><sup>52</sup>;2<sup>52</sup>[ may have
a fractional part. Float.max_frac_float is the greatest
positive <code>float</code> with a fractional part.<br/>Any integer value in the interval [<code>-2</code><sup>53</sup>;2<sup>53</sup>] can be
represented exactly by a <code>float</code> value. <span style="font-style: italic">Integer</span> arithmetic
performed in this interval is exact. Float.max_int_arith is
2<sup>53</sup>.</div></div></div></div></body></html>