<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>HardCamlAffirm__Bmc (hardcaml-affirm.HardCamlAffirm__Bmc)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0"/></head><body><nav><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../index.html">hardcaml-affirm</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">HardCamlAffirm__Bmc</span></h1></header><div class="spec module" id="module-Init_state"><a href="#module-Init_state" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Init_state/index.html">Init_state</a> : <span class="keyword">functor</span> (<a href="Init_state/argument-1-B/index.html">B</a> : <a href="../../hardcaml/HardCaml/Comb/index.html#module-type-S">HardCaml.Comb.S</a>) -&gt; <span class="keyword">functor</span> (<a href="Init_state/argument-2-B_sim/index.html">B_sim</a> : <a href="../../hardcaml/HardCaml/Comb/index.html#module-type-S">HardCaml.Comb.S</a>) -&gt; <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><div class="spec module" id="module-Unroller"><a href="#module-Unroller" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Unroller/index.html">Unroller</a> : <span class="keyword">functor</span> (<a href="Unroller/argument-1-B/index.html">B</a> : <a href="../../hardcaml/HardCaml/Comb/index.html#module-type-S">HardCaml.Comb.S</a>) -&gt; <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"><p>Unroll circuit</p></div></div><div class="spec module" id="module-LTL"><a href="#module-LTL" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="LTL/index.html">LTL</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><div class="spec val" id="val-transform_regs"><a href="#val-transform_regs" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>transform_regs : reset:bool<span class="keyword"> -&gt; </span>clear:bool<span class="keyword"> -&gt; </span>enable:bool<span class="keyword"> -&gt; </span><a href="../HardCamlAffirm__Props/LTL/index.html#type-path">HardCamlAffirm.Props.LTL.path</a><span class="keyword"> -&gt; </span><a href="../HardCamlAffirm__Props/LTL/index.html#type-path">HardCamlAffirm.Props.LTL.path</a></code></div><div class="doc"><p>By default the BMC routines ignore the register reset/clear/enable.</p><p>To keep them they should be converted into muxes at the front of the registers.
This function will extract a circuit from the LTL specification, transform it
optionally generating muxes for the reset/clear/enable signals, then rewrite the
LTL formula with the revised atomic propositions</p></div></div><div class="spec val" id="val-compile"><a href="#val-compile" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compile : ?verbose:bool<span class="keyword"> -&gt; </span>?init_state:(<a href="../../hardcaml/HardCaml__Signal/Comb/index.html#type-t">HardCaml.Signal.Comb.t</a><span class="keyword"> -&gt; </span><a href="../../hardcaml/HardCaml__Signal/Comb/index.html#type-t">HardCaml.Signal.Comb.t</a>)<span class="keyword"> -&gt; </span>k:int<span class="keyword"> -&gt; </span><a href="../HardCamlAffirm__Props/LTL/index.html#type-path">HardCamlAffirm.Props.LTL.path</a><span class="keyword"> -&gt; </span><a href="../../hardcaml/HardCaml__Signal/Comb/index.html#type-t">HardCaml.Signal.Comb.t</a></code></div><div class="doc"><p>generate a BMC formula for a circuit and LTL formula over k&gt;=0 time steps.</p></div></div><div class="spec type" id="type-bmc_result"><a href="#type-bmc_result" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>bmc_result</code><code><span class="keyword"> = </span>(int<span class="keyword"> * </span>(string<span class="keyword"> * </span>string array) list) <a href="../../sattools/Sattools/Result/index.html#type-t">Sattools.Result.t</a></code><code></code></div><div class="doc"></div></div><div class="spec val" id="val-run1"><a href="#val-run1" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>run1 : ?verbose:bool<span class="keyword"> -&gt; </span>?init_state:(<a href="../../hardcaml/HardCaml__Signal/Comb/index.html#type-t">HardCaml.Signal.Comb.t</a><span class="keyword"> -&gt; </span><a href="../../hardcaml/HardCaml__Signal/Comb/index.html#type-t">HardCaml.Signal.Comb.t</a>)<span class="keyword"> -&gt; </span>k:int<span class="keyword"> -&gt; </span><a href="../HardCamlAffirm__Props/LTL/index.html#type-path">HardCamlAffirm.Props.LTL.path</a><span class="keyword"> -&gt; </span><a href="index.html#type-bmc_result">bmc_result</a></code></div><div class="doc"><p>run BMC with bound k</p></div></div><div class="spec val" id="val-print"><a href="#val-print" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>print : ?init_state:(<a href="../../hardcaml/HardCaml__Signal/Comb/index.html#type-t">HardCaml.Signal.Comb.t</a><span class="keyword"> -&gt; </span><a href="../../hardcaml/HardCaml__Signal/Comb/index.html#type-t">HardCaml.Signal.Comb.t</a>)<span class="keyword"> -&gt; </span>k:int<span class="keyword"> -&gt; </span><a href="../HardCamlAffirm__Props/LTL/index.html#type-path">HardCamlAffirm.Props.LTL.path</a><span class="keyword"> -&gt; </span>unit</code></div><div class="doc"></div></div><div class="spec val" id="val-run"><a href="#val-run" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>run : ?verbose:bool<span class="keyword"> -&gt; </span>?init_state:(<a href="../../hardcaml/HardCaml__Signal/Comb/index.html#type-t">HardCaml.Signal.Comb.t</a><span class="keyword"> -&gt; </span><a href="../../hardcaml/HardCaml__Signal/Comb/index.html#type-t">HardCaml.Signal.Comb.t</a>)<span class="keyword"> -&gt; </span>k:int<span class="keyword"> -&gt; </span><a href="../HardCamlAffirm__Props/LTL/index.html#type-path">HardCamlAffirm.Props.LTL.path</a><span class="keyword"> -&gt; </span><a href="index.html#type-bmc_result">bmc_result</a></code></div><div class="doc"><p>Iteratively run BMC for up to k time steps</p></div></div><p>Interface flow</p><div class="spec type" id="type-bmc"><a href="#type-bmc" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>bmc</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-bmc.run" class="anchored"><td class="def field"><a href="#type-bmc.run" class="anchor"></a><code>run : ?verbose:bool<span class="keyword"> -&gt; </span>int<span class="keyword"> -&gt; </span><a href="index.html#type-bmc_result">bmc_result</a>;</code></td></tr><tr id="type-bmc.run1" class="anchored"><td class="def field"><a href="#type-bmc.run1" class="anchor"></a><code>run1 : ?verbose:bool<span class="keyword"> -&gt; </span>int<span class="keyword"> -&gt; </span><a href="index.html#type-bmc_result">bmc_result</a>;</code></td></tr></table><code>}</code><code></code></div><div class="doc"></div></div><div class="spec module" id="module-Gen"><a href="#module-Gen" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Gen/index.html">Gen</a> : <span class="keyword">functor</span> (<a href="Gen/argument-1-I/index.html">I</a> : <a href="../../hardcaml/HardCaml/Interface/index.html#module-type-S">HardCaml.Interface.S</a>) -&gt; <span class="keyword">functor</span> (<a href="Gen/argument-2-O/index.html">O</a> : <a href="../../hardcaml/HardCaml/Interface/index.html#module-type-S">HardCaml.Interface.S</a>) -&gt; <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><div class="spec module" id="module-Gen_with_sim"><a href="#module-Gen_with_sim" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Gen_with_sim/index.html">Gen_with_sim</a> : <span class="keyword">functor</span> (<a href="Gen_with_sim/argument-1-B/index.html">B</a> : <a href="../../hardcaml/HardCaml/Comb/index.html#module-type-S">HardCaml.Comb.S</a>) -&gt; <span class="keyword">functor</span> (<a href="Gen_with_sim/argument-2-I/index.html">I</a> : <a href="../../hardcaml/HardCaml/Interface/index.html#module-type-S">HardCaml.Interface.S</a>) -&gt; <span class="keyword">functor</span> (<a href="Gen_with_sim/argument-3-O/index.html">O</a> : <a href="../../hardcaml/HardCaml/Interface/index.html#module-type-S">HardCaml.Interface.S</a>) -&gt; <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div></body></html>