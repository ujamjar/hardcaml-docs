<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>UidSet (hardcaml.Signal.Types.UidSet)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/></head><body><div class="odoc-doc"><a href="../index.html">Up</a><div class="intro"><h1><span class="keyword">Module </span><a href="../#/UidSet">UidSet</a></h1></div><div class="mod"><div class="def"><span class="keyword">module </span>UidSet : <a href="../../../../ocaml/Set/S.modt/index.html">Set.S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="../../../../ocaml/Set/S.modt/index.html#/elt.typ">elt</a> = <a href="../index.html#/uid.typ">uid</a></div><div class="doc"></div><hr/><div><div class="region" id="/elt.typ"><a href="#/elt.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>elt = <a href="../index.html#/uid.typ">uid</a></div><div class="doc">The type of the set elements.</div></div></div><div class="region" id="/t.typ"><a href="#/t.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>t</div><div class="doc">The type of sets.</div></div></div><div class="region" id="/empty.val"><a href="#/empty.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>empty : <a href="index.html#/t.typ">t</a></div><div class="doc">The empty set.</div></div></div><div class="region" id="/is_empty.val"><a href="#/is_empty.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>is_empty : <a href="index.html#/t.typ">t</a> -&gt; bool</div><div class="doc">Test whether a set is empty or not.</div></div></div><div class="region" id="/mem.val"><a href="#/mem.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>mem : <a href="index.html#/elt.typ">elt</a> -&gt; <a href="index.html#/t.typ">t</a> -&gt; bool</div><div class="doc"><code>mem x s</code> tests whether <code>x</code> belongs to the set <code>s</code>.</div></div></div><div class="region" id="/add.val"><a href="#/add.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>add : <a href="index.html#/elt.typ">elt</a> -&gt; <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/t.typ">t</a></div><div class="doc"><code>add x s</code> returns a set containing all elements of <code>s</code>,
plus <code>x</code>. If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged
(the result of the function is then physically equal to <code>s</code>).</div></div></div><div class="region" id="/singleton.val"><a href="#/singleton.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>singleton : <a href="index.html#/elt.typ">elt</a> -&gt; <a href="index.html#/t.typ">t</a></div><div class="doc"><code>singleton x</code> returns the one-element set containing only <code>x</code>.</div></div></div><div class="region" id="/remove.val"><a href="#/remove.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>remove : <a href="index.html#/elt.typ">elt</a> -&gt; <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/t.typ">t</a></div><div class="doc"><code>remove x s</code> returns a set containing all elements of <code>s</code>,
except <code>x</code>. If <code>x</code> was not in <code>s</code>, <code>s</code> is returned unchanged
(the result of the function is then physically equal to <code>s</code>).</div></div></div><div class="region" id="/union.val"><a href="#/union.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>union : <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/t.typ">t</a></div><div class="doc">Set union.</div></div></div><div class="region" id="/inter.val"><a href="#/inter.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>inter : <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/t.typ">t</a></div><div class="doc">Set intersection.</div></div></div><div class="region" id="/diff.val"><a href="#/diff.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>diff : <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/t.typ">t</a></div><div class="doc">Set difference.</div></div></div><div class="region" id="/compare.val"><a href="#/compare.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>compare : <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/t.typ">t</a> -&gt; int</div><div class="doc">Total ordering between sets. Can be used as the ordering function
for doing sets of sets.</div></div></div><div class="region" id="/equal.val"><a href="#/equal.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>equal : <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/t.typ">t</a> -&gt; bool</div><div class="doc"><code>equal s1 s2</code> tests whether the sets <code>s1</code> and <code>s2</code> are
equal, that is, contain equal elements.</div></div></div><div class="region" id="/subset.val"><a href="#/subset.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>subset : <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/t.typ">t</a> -&gt; bool</div><div class="doc"><code>subset s1 s2</code> tests whether the set <code>s1</code> is a subset of
the set <code>s2</code>.</div></div></div><div class="region" id="/iter.val"><a href="#/iter.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>iter : (<a href="index.html#/elt.typ">elt</a> -&gt; unit) -&gt; <a href="index.html#/t.typ">t</a> -&gt; unit</div><div class="doc"><code>iter f s</code> applies <code>f</code> in turn to all elements of <code>s</code>.
The elements of <code>s</code> are presented to <code>f</code> in increasing order
with respect to the ordering over the type of the elements.</div></div></div><div class="region" id="/fold.val"><a href="#/fold.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>fold : (<a href="index.html#/elt.typ">elt</a> -&gt; 'a -&gt; 'a) -&gt; <a href="index.html#/t.typ">t</a> -&gt; 'a -&gt; 'a</div><div class="doc"><code>fold f s a</code> computes <code>(f xN ... (f x2 (f x1 a))...)</code>,
where <code>x1 ... xN</code> are the elements of <code>s</code>, in increasing order.</div></div></div><div class="region" id="/for_all.val"><a href="#/for_all.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>for_all : (<a href="index.html#/elt.typ">elt</a> -&gt; bool) -&gt; <a href="index.html#/t.typ">t</a> -&gt; bool</div><div class="doc"><code>for_all p s</code> checks if all elements of the set
satisfy the predicate <code>p</code>.</div></div></div><div class="region" id="/exists.val"><a href="#/exists.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>exists : (<a href="index.html#/elt.typ">elt</a> -&gt; bool) -&gt; <a href="index.html#/t.typ">t</a> -&gt; bool</div><div class="doc"><code>exists p s</code> checks if at least one element of
the set satisfies the predicate <code>p</code>.</div></div></div><div class="region" id="/filter.val"><a href="#/filter.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>filter : (<a href="index.html#/elt.typ">elt</a> -&gt; bool) -&gt; <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/t.typ">t</a></div><div class="doc"><code>filter p s</code> returns the set of all elements in <code>s</code>
that satisfy predicate <code>p</code>. If <code>p</code> satisfies every element in <code>s</code>,
<code>s</code> is returned unchanged (the result of the function is then
physically equal to <code>s</code>).</div></div></div><div class="region" id="/partition.val"><a href="#/partition.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>partition : (<a href="index.html#/elt.typ">elt</a> -&gt; bool) -&gt; <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/t.typ">t</a> * <a href="index.html#/t.typ">t</a></div><div class="doc"><code>partition p s</code> returns a pair of sets <code>(s1, s2)</code>, where
<code>s1</code> is the set of all the elements of <code>s</code> that satisfy the
predicate <code>p</code>, and <code>s2</code> is the set of all the elements of
<code>s</code> that do not satisfy <code>p</code>.</div></div></div><div class="region" id="/cardinal.val"><a href="#/cardinal.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>cardinal : <a href="index.html#/t.typ">t</a> -&gt; int</div><div class="doc">Return the number of elements of a set.</div></div></div><div class="region" id="/elements.val"><a href="#/elements.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>elements : <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/elt.typ">elt</a> list</div><div class="doc">Return the list of all elements of the given set.
The returned list is sorted in increasing order with respect
to the ordering <code>Ord.compare</code>, where <code>Ord</code> is the argument
given to Set.Make.</div></div></div><div class="region" id="/min_elt.val"><a href="#/min_elt.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>min_elt : <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/elt.typ">elt</a></div><div class="doc">Return the smallest element of the given set
(with respect to the <code>Ord.compare</code> ordering), or raise
<code>Not_found</code> if the set is empty.</div></div></div><div class="region" id="/max_elt.val"><a href="#/max_elt.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>max_elt : <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/elt.typ">elt</a></div><div class="doc">Same as Set.S.min_elt, but returns the largest element of the
given set.</div></div></div><div class="region" id="/choose.val"><a href="#/choose.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>choose : <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/elt.typ">elt</a></div><div class="doc">Return one element of the given set, or raise <code>Not_found</code> if
the set is empty. Which element is chosen is unspecified,
but equal elements will be chosen for equal sets.</div></div></div><div class="region" id="/split.val"><a href="#/split.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>split : <a href="index.html#/elt.typ">elt</a> -&gt; <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/t.typ">t</a> * bool * <a href="index.html#/t.typ">t</a></div><div class="doc"><code>split x s</code> returns a triple <code>(l, present, r)</code>, where
<code>l</code> is the set of elements of <code>s</code> that are
strictly less than <code>x</code>;
<code>r</code> is the set of elements of <code>s</code> that are
strictly greater than <code>x</code>;
<code>present</code> is <code>false</code> if <code>s</code> contains no element equal to <code>x</code>,
or <code>true</code> if <code>s</code> contains an element equal to <code>x</code>.</div></div></div><div class="region" id="/find.val"><a href="#/find.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>find : <a href="index.html#/elt.typ">elt</a> -&gt; <a href="index.html#/t.typ">t</a> -&gt; <a href="index.html#/elt.typ">elt</a></div><div class="doc"><code>find x s</code> returns the element of <code>s</code> equal to <code>x</code> (according
to <code>Ord.compare</code>), or raise <code>Not_found</code> if no such element
exists.</div></div></div><div class="region" id="/of_list.val"><a href="#/of_list.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>of_list : <a href="index.html#/elt.typ">elt</a> list -&gt; <a href="index.html#/t.typ">t</a></div><div class="doc"><code>of_list l</code> creates a set from a list of elements.
This is usually more efficient than folding <code>add</code> over the list,
except perhaps for lists with many duplicated elements.</div></div></div></div></div></div></body></html>