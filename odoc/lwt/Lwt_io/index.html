<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lwt_io (lwt.Lwt_io)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/></head><body><div class="odoc-doc"><a href="../index.html">Up</a><div class="intro"><h1><span class="keyword">Module </span><a href="../#/Lwt_io">Lwt_io</a></h1></div><div><div class="doc">Buffered byte channels</div><div><div class="doc">A <span style="font-weight: bold">channel</span> is a high-level object for performing input/output
(IO). It allows to read/write from/to the outside world in an
efficient way, by minimising the number of system calls.<br/>An <span style="font-weight: bold">output channel</span> is used to send data and an <span style="font-weight: bold">input
channel</span> is used to receive data.<br/>If you are familiar with buffered channels you may be familiar too
with the <span style="font-weight: bold">flush</span> operation. Note that byte channels of this
module are automatically flushed when there is nothing else to do
(i.e. before the program becomes idle), so this means that you no
longer have to write:<br/><pre>
      eprintf &quot;log message\n&quot;;
      flush stderr;
    </pre><br/>to have your messages displayed.<br/>Note about errors: input functions of this module raise
<code>End_of_file</code> when the end-of-file is reached (i.e. when the read
function returns <code>0</code>). Other exceptions are ones caused by the
backend read/write functions, such as <code>Unix.Unix_error</code>.</div><div class="exn"><div class="def"><span class="keyword">exn </span>Channel_closed of string</div><div class="doc">Exception raised when a channel is closed. The parameter is a
description of the channel.</div></div><div class="doc"><h2>Types</h2></div><div class="region" id="/channel.typ"><a href="#/channel.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>'mode channel</div><div class="doc">Type of buffered byte channels</div></div></div><div class="region" id="/input.typ"><a href="#/input.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>input</div><div class="doc">Input mode</div></div></div><div class="region" id="/output.typ"><a href="#/output.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>output</div><div class="doc">Output mode</div></div></div><div class="region" id="/mode.typ"><a href="#/mode.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>'a mode = <table><tr class="cons"><td><div class="region" id="/mode.typ/Input.cons"><a href="#/mode.typ/Input.cons" class="anchor"></a>| Input</div></td></tr><tr class="cons"><td><div class="region" id="/mode.typ/Output.cons"><a href="#/mode.typ/Output.cons" class="anchor"></a>| Output</div></td></tr></table></div><div class="doc">Channel mode</div></div></div><div class="region" id="/input.val"><a href="#/input.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>input : <a href="index.html#/input.typ">input</a> <a href="index.html#/mode.typ">mode</a></div><div class="doc"><code>input</code> input mode representation</div></div></div><div class="region" id="/output.val"><a href="#/output.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>output : <a href="index.html#/output.typ">output</a> <a href="index.html#/mode.typ">mode</a></div><div class="doc"><code>output</code> output mode representation</div></div></div><div class="region" id="/input_channel.typ"><a href="#/input_channel.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>input_channel = <a href="index.html#/input.typ">input</a> <a href="index.html#/channel.typ">channel</a></div><div class="doc">Type of input channels</div></div></div><div class="region" id="/output_channel.typ"><a href="#/output_channel.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>output_channel = <a href="index.html#/output.typ">output</a> <a href="index.html#/channel.typ">channel</a></div><div class="doc">Type of output channels</div></div></div><div class="region" id="/mode.val"><a href="#/mode.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>mode : 'a <a href="index.html#/channel.typ">channel</a> -&gt; 'a <a href="index.html#/mode.typ">mode</a></div><div class="doc"><code>mode ch</code> returns the mode of a channel</div></div></div><div class="doc"><h2>Well-known instances</h2></div><div class="region" id="/stdin.val"><a href="#/stdin.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>stdin : <a href="index.html#/input_channel.typ">input_channel</a></div><div class="doc">The standard input, it reads data from Lwt_unix.stdin</div></div></div><div class="region" id="/stdout.val"><a href="#/stdout.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>stdout : <a href="index.html#/output_channel.typ">output_channel</a></div><div class="doc">The standard output, it writes data to Lwt_unix.stdout</div></div></div><div class="region" id="/stderr.val"><a href="#/stderr.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>stderr : <a href="index.html#/output_channel.typ">output_channel</a></div><div class="doc">The standard output for error messages, it writes data to
Lwt_unix.stderr</div></div></div><div class="region" id="/zero.val"><a href="#/zero.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>zero : <a href="index.html#/input_channel.typ">input_channel</a></div><div class="doc">Inputs which returns always <code>'\x00'</code></div></div></div><div class="region" id="/null.val"><a href="#/null.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>null : <a href="index.html#/output_channel.typ">output_channel</a></div><div class="doc">Output which drops everything</div></div></div><div class="doc"><h2>Channels creation/manipulation</h2></div><div class="region" id="/pipe.val"><a href="#/pipe.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>pipe : ?in_buffer:<a href="../Lwt_bytes/index.html#/t.typ">Lwt_bytes.t</a> -&gt; ?out_buffer:<a href="../Lwt_bytes/index.html#/t.typ">Lwt_bytes.t</a> -&gt; unit -&gt; <a href="index.html#/input_channel.typ">input_channel</a> * <a href="index.html#/output_channel.typ">output_channel</a></div><div class="doc"><code>pipe ?in_buffer ?out_buffer ()</code> creates a pipe using
Lwt_unix.pipe and makes two channels from the two returned file
descriptors</div></div></div><div class="region" id="/make.val"><a href="#/make.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>make : ?buffer:<a href="../Lwt_bytes/index.html#/t.typ">Lwt_bytes.t</a> -&gt; ?close:(unit -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; ?seek:(int64 -&gt; Unix.seek_command -&gt; int64 <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; mode:'mode <a href="index.html#/mode.typ">mode</a> -&gt; (<a href="../Lwt_bytes/index.html#/t.typ">Lwt_bytes.t</a> -&gt; int -&gt; int -&gt; int <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'mode <a href="index.html#/channel.typ">channel</a></div><div class="doc"><code>make ?buffer ?close ~mode perform_io</code> is the
main function for creating new channels.</div></div></div><div class="region" id="/of_bytes.val"><a href="#/of_bytes.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>of_bytes : mode:'mode <a href="index.html#/mode.typ">mode</a> -&gt; <a href="../Lwt_bytes/index.html#/t.typ">Lwt_bytes.t</a> -&gt; 'mode <a href="index.html#/channel.typ">channel</a></div><div class="doc">Create a channel from a byte array. Reading/writing is done
directly on the provided array.</div></div></div><div class="region" id="/of_fd.val"><a href="#/of_fd.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>of_fd : ?buffer:<a href="../Lwt_bytes/index.html#/t.typ">Lwt_bytes.t</a> -&gt; ?close:(unit -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; mode:'mode <a href="index.html#/mode.typ">mode</a> -&gt; <a href="../Lwt_unix/index.html#/file_descr.typ">Lwt_unix.file_descr</a> -&gt; 'mode <a href="index.html#/channel.typ">channel</a></div><div class="doc"><code>of_fd ?buffer ?close ~mode fd</code> creates a channel from a
file descriptor.</div></div></div><div class="region" id="/of_unix_fd.val"><a href="#/of_unix_fd.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>of_unix_fd : ?buffer:<a href="../Lwt_bytes/index.html#/t.typ">Lwt_bytes.t</a> -&gt; ?close:(unit -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; mode:'mode <a href="index.html#/mode.typ">mode</a> -&gt; Unix.file_descr -&gt; 'mode <a href="index.html#/channel.typ">channel</a></div><div class="doc"><code>of_unix_fd ?buffer ?close ~mode fd</code> is a short-hand for:<br/><code>of_fd ?buffer ?close (Lwt_unix.of_unix_file_descr fd)</code></div></div></div><div class="region" id="/close.val"><a href="#/close.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>close : 'a <a href="index.html#/channel.typ">channel</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>close ch</code> closes the given channel. If <code>ch</code> is an output
channel, it performs all pending actions, flushes it and closes
it. If <code>ch</code> is an input channel, it just closes it immediately.<br/><code>close</code> returns the result of the close function of the
channel. Multiple calls to <code>close</code> will return exactly the same
value.<br/>Note: you cannot use <code>close</code> on channels obtained with
atomic.</div></div></div><div class="region" id="/abort.val"><a href="#/abort.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>abort : 'a <a href="index.html#/channel.typ">channel</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>abort ch</code> abort current operations and close the channel
immediately.</div></div></div><div class="region" id="/atomic.val"><a href="#/atomic.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>atomic : ('a <a href="index.html#/channel.typ">channel</a> -&gt; 'b <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'a <a href="index.html#/channel.typ">channel</a> -&gt; 'b <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>atomic f</code> transforms a sequence of io operations into one
single atomic io operation.<br/>Note:
<ul><li>the channel passed to <code>f</code> is invalid after <code>f</code> terminates</li><li><code>atomic</code> can be called inside another <code>atomic</code></li></ul></div></div></div><div class="region" id="/file_length.val"><a href="#/file_length.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>file_length : string -&gt; int64 <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc">Returns the length of a file</div></div></div><div class="region" id="/buffered.val"><a href="#/buffered.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>buffered : 'a <a href="index.html#/channel.typ">channel</a> -&gt; int</div><div class="doc"><code>buffered oc</code> returns the number of bytes in the buffer</div></div></div><div class="region" id="/flush.val"><a href="#/flush.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>flush : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>flush oc</code> performs all pending writes on <code>oc</code></div></div></div><div class="region" id="/flush_all.val"><a href="#/flush_all.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>flush_all : unit -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>flush_all ()</code> flushes all open output channels</div></div></div><div class="region" id="/buffer_size.val"><a href="#/buffer_size.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>buffer_size : 'a <a href="index.html#/channel.typ">channel</a> -&gt; int</div><div class="doc">Returns the size of the internal buffer.</div></div></div><div class="region" id="/resize_buffer.val"><a href="#/resize_buffer.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>resize_buffer : 'a <a href="index.html#/channel.typ">channel</a> -&gt; int -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc">Resize the internal buffer to the given size</div></div></div><div class="region" id="/is_busy.val"><a href="#/is_busy.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>is_busy : 'a <a href="index.html#/channel.typ">channel</a> -&gt; bool</div><div class="doc"><code>is_busy channel</code> returns whether the given channel is currently
busy. A channel is busy when there is at least one job using it
that has not yet terminated.</div></div></div><div class="doc"><h2>Random access</h2></div><div class="region" id="/position.val"><a href="#/position.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>position : 'a <a href="index.html#/channel.typ">channel</a> -&gt; int64</div><div class="doc"><code>position ch</code> Returns the current position in the channel.</div></div></div><div class="region" id="/set_position.val"><a href="#/set_position.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>set_position : 'a <a href="index.html#/channel.typ">channel</a> -&gt; int64 -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>set_position ch pos</code> Sets the position in the output channel. This
does not work if the channel does not support random access.</div></div></div><div class="region" id="/length.val"><a href="#/length.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>length : 'a <a href="index.html#/channel.typ">channel</a> -&gt; int64 <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc">Returns the length of the channel in bytes</div></div></div><div class="doc"><h2>Reading</h2></div><div class="doc">Note: except for functions dealing with streams (read_chars and
read_lines) all functions are <span style="font-weight: bold">atomic</span>.</div><div class="region" id="/read_char.val"><a href="#/read_char.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read_char : <a href="index.html#/input_channel.typ">input_channel</a> -&gt; char <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>read_char ic</code> reads the next character of <code>ic</code>.</div></div></div><div class="region" id="/read_char_opt.val"><a href="#/read_char_opt.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read_char_opt : <a href="index.html#/input_channel.typ">input_channel</a> -&gt; char option <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc">Same as read_byte but does not raise <code>End_of_file</code> on end of
input</div></div></div><div class="region" id="/read_chars.val"><a href="#/read_chars.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read_chars : <a href="index.html#/input_channel.typ">input_channel</a> -&gt; char <a href="../Lwt_stream/index.html#/t.typ">Lwt_stream.t</a></div><div class="doc"><code>read_chars ic</code> returns a stream holding all characters of
<code>ic</code></div></div></div><div class="region" id="/read_line.val"><a href="#/read_line.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read_line : <a href="index.html#/input_channel.typ">input_channel</a> -&gt; string <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>read_line ic</code> reads one complete line from <code>ic</code> and returns it
without the end of line. End of line is either <code>&quot;\n&quot;</code> or
<code>&quot;\r\n&quot;</code>.<br/>If the end of line is reached before reading any character,
<code>End_of_file</code> is raised. If it is reached before reading an end
of line but characters have already been read, they are
returned.</div></div></div><div class="region" id="/read_line_opt.val"><a href="#/read_line_opt.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read_line_opt : <a href="index.html#/input_channel.typ">input_channel</a> -&gt; string option <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc">Same as read_line but do not raise <code>End_of_file</code> on end of
input.</div></div></div><div class="region" id="/read_lines.val"><a href="#/read_lines.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read_lines : <a href="index.html#/input_channel.typ">input_channel</a> -&gt; string <a href="../Lwt_stream/index.html#/t.typ">Lwt_stream.t</a></div><div class="doc"><code>read_lines ic</code> returns a stream holding all lines of <code>ic</code></div></div></div><div class="region" id="/read.val"><a href="#/read.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read : ?count:int -&gt; <a href="index.html#/input_channel.typ">input_channel</a> -&gt; string <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>read ?count ic</code> reads at most <code>count</code> characters from <code>ic</code>. It
returns <code>&quot;&quot;</code> if the end of input is reached. If <code>count</code> is not
specified, it reads all bytes until the end of input.</div></div></div><div class="region" id="/read_into.val"><a href="#/read_into.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read_into : <a href="index.html#/input_channel.typ">input_channel</a> -&gt; <a href="../../ocaml/Bytes/index.html#/t.typ">Bytes.t</a> -&gt; int -&gt; int -&gt; int <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>read_into ic buffer offset length</code> reads up to <code>length</code> bytes,
stores them in <code>buffer</code> at offset <code>offset</code>, and returns the
number of bytes read.<br/>Note: <code>read_into</code> does not raise <code>End_of_file</code>, it returns a
length of <code>0</code> instead.</div></div></div><div class="region" id="/read_into_exactly.val"><a href="#/read_into_exactly.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read_into_exactly : <a href="index.html#/input_channel.typ">input_channel</a> -&gt; <a href="../../ocaml/Bytes/index.html#/t.typ">Bytes.t</a> -&gt; int -&gt; int -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>read_into_exactly ic buffer offset length</code> reads exactly
<code>length</code> bytes and stores them in <code>buffer</code> at offset <code>offset</code>.</div></div></div><div class="region" id="/read_value.val"><a href="#/read_value.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read_value : <a href="index.html#/input_channel.typ">input_channel</a> -&gt; 'a <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>read_value ic</code> reads a marshaled value from <code>ic</code></div></div></div><div class="doc"><h2>Writing</h2></div><div class="doc">Note: as for reading functions, all functions except
write_chars and write_lines are <span style="font-weight: bold">atomic</span>.<br/>For example if you use write_line in two different threads, the
two operations will be serialized, and lines cannot be mixed.</div><div class="region" id="/write_char.val"><a href="#/write_char.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write_char : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; char -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>write_char oc char</code> writes <code>char</code> on <code>oc</code></div></div></div><div class="region" id="/write_chars.val"><a href="#/write_chars.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write_chars : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; char <a href="../Lwt_stream/index.html#/t.typ">Lwt_stream.t</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>write_chars oc chars</code> writes all characters of <code>chars</code> on
<code>oc</code></div></div></div><div class="region" id="/write.val"><a href="#/write.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; string -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>write oc str</code> writes all characters of <code>str</code> on <code>oc</code></div></div></div><div class="region" id="/write_line.val"><a href="#/write_line.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write_line : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; string -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>write_line oc str</code> writes <code>str</code> on <code>oc</code> followed by a
new-line.</div></div></div><div class="region" id="/write_lines.val"><a href="#/write_lines.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write_lines : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; string <a href="../Lwt_stream/index.html#/t.typ">Lwt_stream.t</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>write_lines oc lines</code> writes all lines of <code>lines</code> to <code>oc</code></div></div></div><div class="region" id="/write_from.val"><a href="#/write_from.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write_from : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; <a href="../../ocaml/Bytes/index.html#/t.typ">Bytes.t</a> -&gt; int -&gt; int -&gt; int <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>write_from oc buffer offset length</code> writes up to <code>length</code> bytes
to <code>oc</code>, from <code>buffer</code> at offset <code>offset</code> and returns the number
of bytes actually written</div></div></div><div class="region" id="/write_from_string.val"><a href="#/write_from_string.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write_from_string : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; string -&gt; int -&gt; int -&gt; int <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc">See write.</div></div></div><div class="region" id="/write_from_exactly.val"><a href="#/write_from_exactly.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write_from_exactly : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; <a href="../../ocaml/Bytes/index.html#/t.typ">Bytes.t</a> -&gt; int -&gt; int -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>write_from_exactly oc buffer offset length</code> writes all <code>length</code>
bytes from <code>buffer</code> at offset <code>offset</code> to <code>oc</code></div></div></div><div class="region" id="/write_from_string_exactly.val"><a href="#/write_from_string_exactly.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write_from_string_exactly : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; string -&gt; int -&gt; int -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc">See write_from_exactly.</div></div></div><div class="region" id="/write_value.val"><a href="#/write_value.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write_value : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; ?flags:<a href="../../ocaml/Marshal/index.html#/extern_flags.typ">Marshal.extern_flags</a> list -&gt; 'a -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>write_value oc ?flags x</code> marshals the value <code>x</code> to <code>oc</code></div></div></div><div class="doc"><h2>Printing</h2></div><div class="doc">These functions are basically helpers. Also you may prefer
using the name printl rather than write_line because it is
shorter.<br/>The general name of a printing function is <code>&lt;prefix&gt;print&lt;suffixes&gt;</code>,<br/>where <code>&lt;prefix&gt;</code> is one of:
<ul><li><code>'f'</code>, which means that the function takes as argument a channel</li><li>nothing, which means that the function prints on stdout</li><li><code>'e'</code>, which means that the function prints on stderr</li></ul>and <code>&lt;suffixes&gt;</code> is a combination of:
<ul><li><code>'l'</code> which means that a new-line character is printed after the message</li><li><code>'f'</code> which means that the function takes as argument a <span style="font-weight: bold">format</span> instead
of a string</li></ul></div><div class="region" id="/fprint.val"><a href="#/fprint.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>fprint : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; string -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/fprintl.val"><a href="#/fprintl.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>fprintl : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; string -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/fprintf.val"><a href="#/fprintf.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>fprintf : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; ('a, unit, string, unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) <a href="../../ocaml/Pervasives/index.html#/format4.typ">Pervasives.format4</a> -&gt; 'a</div><div class="doc"></div></div></div><div class="region" id="/fprintlf.val"><a href="#/fprintlf.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>fprintlf : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; ('a, unit, string, unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) <a href="../../ocaml/Pervasives/index.html#/format4.typ">Pervasives.format4</a> -&gt; 'a</div><div class="doc"></div></div></div><div class="region" id="/print.val"><a href="#/print.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>print : string -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/printl.val"><a href="#/printl.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>printl : string -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/printf.val"><a href="#/printf.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>printf : ('a, unit, string, unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) <a href="../../ocaml/Pervasives/index.html#/format4.typ">Pervasives.format4</a> -&gt; 'a</div><div class="doc"></div></div></div><div class="region" id="/printlf.val"><a href="#/printlf.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>printlf : ('a, unit, string, unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) <a href="../../ocaml/Pervasives/index.html#/format4.typ">Pervasives.format4</a> -&gt; 'a</div><div class="doc"></div></div></div><div class="region" id="/eprint.val"><a href="#/eprint.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>eprint : string -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/eprintl.val"><a href="#/eprintl.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>eprintl : string -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/eprintf.val"><a href="#/eprintf.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>eprintf : ('a, unit, string, unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) <a href="../../ocaml/Pervasives/index.html#/format4.typ">Pervasives.format4</a> -&gt; 'a</div><div class="doc"></div></div></div><div class="region" id="/eprintlf.val"><a href="#/eprintlf.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>eprintlf : ('a, unit, string, unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) <a href="../../ocaml/Pervasives/index.html#/format4.typ">Pervasives.format4</a> -&gt; 'a</div><div class="doc"></div></div></div><div class="doc"><h2>Utilities</h2></div><div class="region" id="/hexdump_stream.val"><a href="#/hexdump_stream.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>hexdump_stream : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; char <a href="../Lwt_stream/index.html#/t.typ">Lwt_stream.t</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>hexdump_stream oc byte_stream</code> produces the same output as the
command <code>hexdump -C</code>.</div></div></div><div class="region" id="/hexdump.val"><a href="#/hexdump.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>hexdump : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; string -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>hexdump oc str = hexdump_stream oc (Lwt_stream.of_string str)</code></div></div></div><div class="doc"><h2>File utilities</h2></div><div class="region" id="/file_name.typ"><a href="#/file_name.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>file_name = string</div><div class="doc">Type of file names</div></div></div><div class="region" id="/open_file.val"><a href="#/open_file.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>open_file : ?buffer:<a href="../Lwt_bytes/index.html#/t.typ">Lwt_bytes.t</a> -&gt; ?flags:Unix.open_flag list -&gt; ?perm:Unix.file_perm -&gt; mode:'a <a href="index.html#/mode.typ">mode</a> -&gt; <a href="index.html#/file_name.typ">file_name</a> -&gt; 'a <a href="index.html#/channel.typ">channel</a> <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>open_file ?buffer ?flags ?perm ~mode filename</code> opens the
file with name <code>filename</code> and returns a channel for
reading/writing it.</div></div></div><div class="region" id="/with_file.val"><a href="#/with_file.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>with_file : ?buffer:<a href="../Lwt_bytes/index.html#/t.typ">Lwt_bytes.t</a> -&gt; ?flags:Unix.open_flag list -&gt; ?perm:Unix.file_perm -&gt; mode:'a <a href="index.html#/mode.typ">mode</a> -&gt; <a href="index.html#/file_name.typ">file_name</a> -&gt; ('a <a href="index.html#/channel.typ">channel</a> -&gt; 'b <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'b <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>with_file ?buffer ?flags ?perm ~mode filename f</code> opens a
file and passes the channel to <code>f</code>. It is ensured that the
channel is closed when <code>f ch</code> terminates (even if it fails).</div></div></div><div class="region" id="/open_connection.val"><a href="#/open_connection.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>open_connection : ?fd:<a href="../Lwt_unix/index.html#/file_descr.typ">Lwt_unix.file_descr</a> -&gt; ?in_buffer:<a href="../Lwt_bytes/index.html#/t.typ">Lwt_bytes.t</a> -&gt; ?out_buffer:<a href="../Lwt_bytes/index.html#/t.typ">Lwt_bytes.t</a> -&gt; Unix.sockaddr -&gt; (<a href="index.html#/input_channel.typ">input_channel</a> * <a href="index.html#/output_channel.typ">output_channel</a>) <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>open_connection ?fd ?in_buffer ?out_buffer addr</code> opens a
connection to the given address and returns two channels for using
it. If <code>fd</code> is not specified, a fresh one will be used.<br/>The connection is completly closed when you close both
channels.</div></div></div><div class="region" id="/with_connection.val"><a href="#/with_connection.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>with_connection : ?fd:<a href="../Lwt_unix/index.html#/file_descr.typ">Lwt_unix.file_descr</a> -&gt; ?in_buffer:<a href="../Lwt_bytes/index.html#/t.typ">Lwt_bytes.t</a> -&gt; ?out_buffer:<a href="../Lwt_bytes/index.html#/t.typ">Lwt_bytes.t</a> -&gt; Unix.sockaddr -&gt; ((<a href="index.html#/input_channel.typ">input_channel</a> * <a href="index.html#/output_channel.typ">output_channel</a>) -&gt; 'a <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'a <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>with_connection ?fd ?in_buffer ?out_buffer addr f</code> opens a
connection to the given address and passes the channels to
<code>f</code></div></div></div><div class="region" id="/server.typ"><a href="#/server.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>server</div><div class="doc">Type of a server</div></div></div><div class="region" id="/establish_server.val"><a href="#/establish_server.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>establish_server : ?fd:<a href="../Lwt_unix/index.html#/file_descr.typ">Lwt_unix.file_descr</a> -&gt; ?buffer_size:int -&gt; ?backlog:int -&gt; Unix.sockaddr -&gt; ((<a href="index.html#/input_channel.typ">input_channel</a> * <a href="index.html#/output_channel.typ">output_channel</a>) -&gt; unit) -&gt; <a href="index.html#/server.typ">server</a></div><div class="doc"><code>establish_server ?fd ?buffer_size ?backlog sockaddr f</code> creates
a server which will listen for incoming connections. New
connections are passed to <code>f</code>. Note that <code>f</code> must not raise any
exception. If <code>fd</code> is not specified, a fresh file descriptor will
be created.<br/><code>backlog</code> is the argument passed to <code>Lwt_unix.listen</code></div></div></div><div class="region" id="/shutdown_server.val"><a href="#/shutdown_server.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>shutdown_server : <a href="index.html#/server.typ">server</a> -&gt; unit</div><div class="doc">Shutdown the given server</div></div></div><div class="region" id="/lines_of_file.val"><a href="#/lines_of_file.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>lines_of_file : <a href="index.html#/file_name.typ">file_name</a> -&gt; string <a href="../Lwt_stream/index.html#/t.typ">Lwt_stream.t</a></div><div class="doc"><code>lines_of_file name</code> returns a stream of all lines of the file
with name <code>name</code>. The file is automatically closed when all
lines have been read.</div></div></div><div class="region" id="/lines_to_file.val"><a href="#/lines_to_file.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>lines_to_file : <a href="index.html#/file_name.typ">file_name</a> -&gt; string <a href="../Lwt_stream/index.html#/t.typ">Lwt_stream.t</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>lines_to_file name lines</code> writes all lines of <code>lines</code> to
file with name <code>name</code>.</div></div></div><div class="region" id="/chars_of_file.val"><a href="#/chars_of_file.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>chars_of_file : <a href="index.html#/file_name.typ">file_name</a> -&gt; char <a href="../Lwt_stream/index.html#/t.typ">Lwt_stream.t</a></div><div class="doc"><code>chars_of_file name</code> returns a stream of all characters of the
file with name <code>name</code>. As for lines_of_file the file is
closed when all characters have been read.</div></div></div><div class="region" id="/chars_to_file.val"><a href="#/chars_to_file.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>chars_to_file : <a href="index.html#/file_name.typ">file_name</a> -&gt; char <a href="../Lwt_stream/index.html#/t.typ">Lwt_stream.t</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>chars_to_file name chars</code> writes all characters of <code>chars</code> to
<code>name</code></div></div></div><div class="doc"><h2>Input/output of integers</h2></div><div class="region" id="/NumberIO.modt"><a href="#/NumberIO.modt" class="anchor"></a><div class="modtype"><div class="def"><span class="keyword">module type </span><a href="NumberIO.modt/index.html">NumberIO</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></div><div class="doc">Common interface for reading/writing integers in binary</div></div></div><div class="region" id="/LE"><a href="#/LE" class="anchor"></a><div class="mod"><div class="def"><span class="keyword">module </span><a href="LE/index.html">LE</a> : <a href="NumberIO.modt/index.html">NumberIO</a></div><div class="doc">Reading/writing of numbers in little-endian</div></div></div><div class="region" id="/BE"><a href="#/BE" class="anchor"></a><div class="mod"><div class="def"><span class="keyword">module </span><a href="BE/index.html">BE</a> : <a href="NumberIO.modt/index.html">NumberIO</a></div><div class="doc">Reading/writing of numbers in big-endian</div></div></div><div class="include"><details><summary><span class="def"><span class="keyword">include </span><a href="NumberIO.modt/index.html">NumberIO</a></span></summary><div><div class="doc"><h3>Reading</h3></div><div class="region" id="/read_int.val"><a href="#/read_int.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read_int : <a href="index.html#/input_channel.typ">input_channel</a> -&gt; int <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc">Reads a 32-bits integer as an ocaml int</div></div></div><div class="region" id="/read_int16.val"><a href="#/read_int16.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read_int16 : <a href="index.html#/input_channel.typ">input_channel</a> -&gt; int <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/read_int32.val"><a href="#/read_int32.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read_int32 : <a href="index.html#/input_channel.typ">input_channel</a> -&gt; int32 <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/read_int64.val"><a href="#/read_int64.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read_int64 : <a href="index.html#/input_channel.typ">input_channel</a> -&gt; int64 <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/read_float32.val"><a href="#/read_float32.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read_float32 : <a href="index.html#/input_channel.typ">input_channel</a> -&gt; float <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc">Reads an IEEE single precision floating point value</div></div></div><div class="region" id="/read_float64.val"><a href="#/read_float64.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>read_float64 : <a href="index.html#/input_channel.typ">input_channel</a> -&gt; float <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc">Reads an IEEE double precision floating point value</div></div></div><div class="doc"><h3>Writing</h3></div><div class="region" id="/write_int.val"><a href="#/write_int.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write_int : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; int -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc">Writes an ocaml int as a 32-bits integer</div></div></div><div class="region" id="/write_int16.val"><a href="#/write_int16.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write_int16 : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; int -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/write_int32.val"><a href="#/write_int32.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write_int32 : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; int32 -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/write_int64.val"><a href="#/write_int64.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write_int64 : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; int64 -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/write_float32.val"><a href="#/write_float32.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write_float32 : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; float -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc">Writes an IEEE single precision floating point value</div></div></div><div class="region" id="/write_float64.val"><a href="#/write_float64.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>write_float64 : <a href="index.html#/output_channel.typ">output_channel</a> -&gt; float -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc">Writes an IEEE double precision floating point value</div></div></div></div></details><div class="doc">Reading/writing of numbers in the system endianness.</div></div><div class="region" id="/byte_order.typ"><a href="#/byte_order.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>byte_order = <a href="../Lwt_sys/index.html#/byte_order.typ">Lwt_sys.byte_order</a> = <table><tr class="cons"><td><div class="region" id="/byte_order.typ/Little_endian.cons"><a href="#/byte_order.typ/Little_endian.cons" class="anchor"></a>| Little_endian</div></td></tr><tr class="cons"><td><div class="region" id="/byte_order.typ/Big_endian.cons"><a href="#/byte_order.typ/Big_endian.cons" class="anchor"></a>| Big_endian</div></td><td>(*</td><td><div class="doc">Type of byte order</div></td><td>*)</td></tr></table></div><div class="doc"></div></div></div><div class="region" id="/system_byte_order.val"><a href="#/system_byte_order.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>system_byte_order : <a href="index.html#/byte_order.typ">byte_order</a></div><div class="doc">Same as <a href="../Lwt_sys/index.html#/byte_order.typ">Lwt_sys.byte_order</a>.</div></div></div><div class="doc"><h2>Low-level access to the internal buffer</h2></div><div class="region" id="/block.val"><a href="#/block.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>block : 'a <a href="index.html#/channel.typ">channel</a> -&gt; int -&gt; (<a href="../Lwt_bytes/index.html#/t.typ">Lwt_bytes.t</a> -&gt; int -&gt; 'b <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'b <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>block ch size f</code> pass to <code>f</code> the internal buffer and an
offset. The buffer contains <code>size</code> chars at <code>offset</code>. <code>f</code> may
read or write these chars. <code>size</code> must satisfy <code>0 &lt;= size &lt;=
      16</code></div></div></div><div class="region" id="/direct_access.typ"><a href="#/direct_access.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>direct_access = {<table><tr class="fld"><td><div class="region" id="/direct_access.typ/da_buffer.fld"><a href="#/direct_access.typ/da_buffer.fld" class="anchor"></a>da_buffer</div></td><td> : </td><td><a href="../Lwt_bytes/index.html#/t.typ">Lwt_bytes.t</a>;</td><td>(*</td><td><div class="doc">The internal buffer</div></td><td>*)</td></tr><tr class="fld"><td><div class="region" id="/direct_access.typ/da_ptr.fld"><a href="#/direct_access.typ/da_ptr.fld" class="anchor"></a><span class="keyword">mutable </span>da_ptr</div></td><td> : </td><td>int;</td><td>(*</td><td><div class="doc">The pointer to:
<ul><li>the beginning of free space for output channels</li><li>the beginning of data for input channels</li></ul></div></td><td>*)</td></tr><tr class="fld"><td><div class="region" id="/direct_access.typ/da_max.fld"><a href="#/direct_access.typ/da_max.fld" class="anchor"></a><span class="keyword">mutable </span>da_max</div></td><td> : </td><td>int;</td><td>(*</td><td><div class="doc">The maximum offset</div></td><td>*)</td></tr><tr class="fld"><td><div class="region" id="/direct_access.typ/da_perform.fld"><a href="#/direct_access.typ/da_perform.fld" class="anchor"></a>da_perform</div></td><td> : </td><td>unit -&gt; int <a href="../Lwt/index.html#/t.typ">Lwt.t</a>;</td><td>(*</td><td><div class="doc">- for input channels:
refills the buffer and returns how many bytes have been read
<ul><li>for output channels:
flush partially the buffer and returns how many bytes have been written</li></ul></div></td><td>*)</td></tr></table>}</div><div class="doc">Information for directly accessing the internal buffer of a
channel</div></div></div><div class="region" id="/direct_access.val"><a href="#/direct_access.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>direct_access : 'a <a href="index.html#/channel.typ">channel</a> -&gt; (<a href="index.html#/direct_access.typ">direct_access</a> -&gt; 'b <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'b <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>direct_access ch f</code> passes to <code>f</code> a <a href="index.html#/direct_access.typ">direct_access</a>
structure. <code>f</code> must use it and update <code>da_ptr</code> to reflect how
many bytes have been read/written.</div></div></div><div class="doc"><h2>Misc</h2></div><div class="region" id="/default_buffer_size.val"><a href="#/default_buffer_size.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>default_buffer_size : unit -&gt; int</div><div class="doc">Return the default size for buffers. Channels that are created
without a specific buffer use new buffer of this size.</div></div></div><div class="region" id="/set_default_buffer_size.val"><a href="#/set_default_buffer_size.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>set_default_buffer_size : int -&gt; unit</div><div class="doc">Change the default buffer size.</div></div></div></div></div></div></body></html>