<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lwt_stream (lwt.Lwt_stream)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/></head><body><div class="odoc-doc"><a href="../index.html">Up</a><div class="intro"><h1><span class="keyword">Module </span><a href="../#/Lwt_stream">Lwt_stream</a></h1></div><div><div class="doc">Data streams</div><div><div class="region" id="/t.typ"><a href="#/t.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>'a t</div><div class="doc">Type of a stream holding values of type <code>'a</code></div></div></div><div class="doc">Naming convention: in this module all function taking a function
which is applied to all element of the streams are suffixed by:<br/><ul><li><code>_s</code> when the function returns a thread and calls are serialised</li><li><code>_p</code> when the function returns a thread and calls are parallelised</li></ul></div><div class="doc"><h2>Construction</h2></div><div class="region" id="/from.val"><a href="#/from.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>from : (unit -&gt; 'a option <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'a <a href="index.html#/t.typ">t</a></div><div class="doc"><code>from f</code> creates an stream from the given input function. <code>f</code> is
called each time more input is needed, and the stream ends when
<code>f</code> returns <code>None</code>.</div></div></div><div class="region" id="/from_direct.val"><a href="#/from_direct.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>from_direct : (unit -&gt; 'a option) -&gt; 'a <a href="index.html#/t.typ">t</a></div><div class="doc"><code>from_direct f</code> does the same as from but with a function
that does not return a thread. It is better than wrapping <code>f</code>
into a function which returns a thread.</div></div></div><div class="exn"><div class="def"><span class="keyword">exn </span>Closed</div><div class="doc">Exception raised by the push function of a push-stream when
pushing an element after the end of stream (<code>= None</code>) have been
pushed.</div></div><div class="region" id="/create.val"><a href="#/create.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>create : unit -&gt; 'a <a href="index.html#/t.typ">t</a> * ('a option -&gt; unit)</div><div class="doc"><code>create ()</code> returns a new stream and a push function.</div></div></div><div class="region" id="/create_with_reference.val"><a href="#/create_with_reference.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>create_with_reference : unit -&gt; 'a <a href="index.html#/t.typ">t</a> * ('a option -&gt; unit) * ('b -&gt; unit)</div><div class="doc"><code>create_with_reference ()</code> returns a new stream and a push
function. The last function allows a reference to be set to an
external source. This prevents the external source from being
garbage collected.<br/>For example, to convert a reactive event to a stream:<br/><pre>
        let stream, push, set_ref = Lwt_stream.create_with_reference () in
        set_ref (map_event push event)
      </pre></div></div></div><div class="exn"><div class="def"><span class="keyword">exn </span>Full</div><div class="doc">Exception raised by the push function of a bounded push-stream
when the stream queue is full and a thread is already waiting to
push an element.</div></div><div class="classtype"><div class="def"><span class="keyword">class type </span>bounded_push</div><div class="doc">Type of sources for bounded push-streams.</div></div><div class="region" id="/create_bounded.val"><a href="#/create_bounded.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>create_bounded : int -&gt; 'a <a href="index.html#/t.typ">t</a> * 'a bounded_push</div><div class="doc"><code>create_bounded size</code> returns a new stream and a bounded push
source. The stream can hold a maximum of <code>size</code> elements. When
this limit is reached, pushing a new element will block until
one is consumed.<br/>Note that you cannot clone or parse (with parse) a bounded
stream. These functions will raise <code>Invalid_argument</code> if you try
to do so.<br/>It raises <code>Invalid_argument</code> if <code>size &lt; 0</code>.</div></div></div><div class="region" id="/of_list.val"><a href="#/of_list.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>of_list : 'a list -&gt; 'a <a href="index.html#/t.typ">t</a></div><div class="doc"><code>of_list l</code> creates a stream returning all elements of <code>l</code></div></div></div><div class="region" id="/of_array.val"><a href="#/of_array.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>of_array : 'a array -&gt; 'a <a href="index.html#/t.typ">t</a></div><div class="doc"><code>of_array a</code> creates a stream returning all elements of <code>a</code></div></div></div><div class="region" id="/of_string.val"><a href="#/of_string.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>of_string : string -&gt; char <a href="index.html#/t.typ">t</a></div><div class="doc"><code>of_string str</code> creates a stream returning all characters of
<code>str</code></div></div></div><div class="region" id="/clone.val"><a href="#/clone.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>clone : 'a <a href="index.html#/t.typ">t</a> -&gt; 'a <a href="index.html#/t.typ">t</a></div><div class="doc"><code>clone st</code> clone the given stream. Operations on each stream
will not affect the other.<br/>For example:<br/><pre>
        # let st1 = Lwt_stream.of_list [1; 2; 3];;
        val st1 : int Lwt_stream.t = &lt;abstr&gt;
        # let st2 = Lwt_stream.clone st1;;
        val st2 : int Lwt_stream.t = &lt;abstr&gt;
        # lwt x = Lwt_stream.next st1;;
        val x : int = 1
        # lwt y = Lwt_stream.next st2;;
        val y : int = 1
      </pre><br/>It raises <code>Invalid_argument</code> if <code>st</code> is a bounded
push-stream.</div></div></div><div class="doc"><h2>Destruction</h2></div><div class="region" id="/to_list.val"><a href="#/to_list.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>to_list : 'a <a href="index.html#/t.typ">t</a> -&gt; 'a list <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc">Returns the list of elements of the given stream</div></div></div><div class="region" id="/to_string.val"><a href="#/to_string.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>to_string : char <a href="index.html#/t.typ">t</a> -&gt; string <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc">Returns the word composed of all characters of the given
stream</div></div></div><div class="doc"><h2>Data retreival</h2></div><div class="exn"><div class="def"><span class="keyword">exn </span>Empty</div><div class="doc">Exception raised when trying to retreive data from an empty
stream.</div></div><div class="region" id="/peek.val"><a href="#/peek.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>peek : 'a <a href="index.html#/t.typ">t</a> -&gt; 'a option <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>peek st</code> returns the first element of the stream, if any,
without removing it.</div></div></div><div class="region" id="/npeek.val"><a href="#/npeek.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>npeek : int -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'a list <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>npeek n st</code> returns at most the first <code>n</code> elements of <code>st</code>,
without removing them.</div></div></div><div class="region" id="/get.val"><a href="#/get.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>get : 'a <a href="index.html#/t.typ">t</a> -&gt; 'a option <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>get st</code> remove and returns the first element of the stream, if
any.</div></div></div><div class="region" id="/nget.val"><a href="#/nget.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>nget : int -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'a list <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>nget n st</code> remove and returns at most the first <code>n</code> elements of
<code>st</code>.</div></div></div><div class="region" id="/get_while.val"><a href="#/get_while.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>get_while : ('a -&gt; bool) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'a list <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/get_while_s.val"><a href="#/get_while_s.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>get_while_s : ('a -&gt; bool <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'a list <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>get_while f st</code> returns the longest prefix of <code>st</code> where all
elements satisfy <code>f</code>.</div></div></div><div class="region" id="/next.val"><a href="#/next.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>next : 'a <a href="index.html#/t.typ">t</a> -&gt; 'a <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>next st</code> remove and returns the next element of the stream, of
fail with Empty if the stream is empty.</div></div></div><div class="region" id="/last_new.val"><a href="#/last_new.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>last_new : 'a <a href="index.html#/t.typ">t</a> -&gt; 'a <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>last_new st</code> returns the last element that can be obtained
without sleepping, or wait for one if no one is already
available.<br/>If fails with Empty if the stream has no more elements</div></div></div><div class="region" id="/junk.val"><a href="#/junk.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>junk : 'a <a href="index.html#/t.typ">t</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>junk st</code> remove the first element of <code>st</code>.</div></div></div><div class="region" id="/njunk.val"><a href="#/njunk.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>njunk : int -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>njunk n st</code> removes at most the first <code>n</code> elements of the
stream.</div></div></div><div class="region" id="/junk_while.val"><a href="#/junk_while.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>junk_while : ('a -&gt; bool) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/junk_while_s.val"><a href="#/junk_while_s.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>junk_while_s : ('a -&gt; bool <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>junk_while f st</code> removes all elements at the beginning of the
streams which satisfy <code>f</code>.</div></div></div><div class="region" id="/junk_old.val"><a href="#/junk_old.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>junk_old : 'a <a href="index.html#/t.typ">t</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>junk_old st</code> removes all elements that are ready to be read
without yeilding from <code>st</code>.<br/>For example the <code>read_password</code> function of <code>Lwt_read_line</code> use
that to junk key previously typed by the user.</div></div></div><div class="region" id="/get_available.val"><a href="#/get_available.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>get_available : 'a <a href="index.html#/t.typ">t</a> -&gt; 'a list</div><div class="doc"><code>get_available st</code> returns all available elements of <code>l</code> without
blocking</div></div></div><div class="region" id="/get_available_up_to.val"><a href="#/get_available_up_to.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>get_available_up_to : int -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'a list</div><div class="doc"><code>get_available_up_to n st</code> returns up to <code>n</code> elements of <code>l</code>
without blocking</div></div></div><div class="region" id="/is_empty.val"><a href="#/is_empty.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>is_empty : 'a <a href="index.html#/t.typ">t</a> -&gt; bool <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>is_empty st</code> returns wether the given stream is empty</div></div></div><div class="region" id="/on_termination.val"><a href="#/on_termination.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>on_termination : 'a <a href="index.html#/t.typ">t</a> -&gt; (unit -&gt; unit) -&gt; unit</div><div class="doc"><code>on_termination st f</code> executes <code>f</code> when the end of the stream <code>st</code>
is reached. Note that the stream may still contains elements if
peek or similar was used.</div></div></div><div class="region" id="/on_terminate.val"><a href="#/on_terminate.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>on_terminate : 'a <a href="index.html#/t.typ">t</a> -&gt; (unit -&gt; unit) -&gt; unit</div><div class="doc"></div></div></div><div class="doc"><h2>Stream transversal</h2></div><div class="doc">Note: all the following functions are destructive.<br/>For example:<br/><pre>
      # let st1 = Lwt_stream.of_list [1; 2; 3];;
      val st1 : int Lwt_stream.t = &lt;abstr&gt;
      # let st2 = Lwt_stream.map string_of_int st1;;
      val st2 : string Lwt_stream.t = &lt;abstr&gt;
      # lwt x = Lwt_stream.next st1;;
      val x : int = 1
      # lwt y = Lwt_stream.next st2;;
      val y : string = &quot;2&quot;
    </pre></div><div class="region" id="/choose.val"><a href="#/choose.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>choose : 'a <a href="index.html#/t.typ">t</a> list -&gt; 'a <a href="index.html#/t.typ">t</a></div><div class="doc"><code>choose l</code> creates an stream from a list of streams. The
resulting stream will returns elements returned by any stream of
<code>l</code> in an unspecified order.</div></div></div><div class="region" id="/map.val"><a href="#/map.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>map : ('a -&gt; 'b) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'b <a href="index.html#/t.typ">t</a></div><div class="doc"></div></div></div><div class="region" id="/map_s.val"><a href="#/map_s.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>map_s : ('a -&gt; 'b <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'b <a href="index.html#/t.typ">t</a></div><div class="doc"><code>map f st</code> maps the value returned by <code>st</code> with <code>f</code></div></div></div><div class="region" id="/filter.val"><a href="#/filter.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>filter : ('a -&gt; bool) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'a <a href="index.html#/t.typ">t</a></div><div class="doc"></div></div></div><div class="region" id="/filter_s.val"><a href="#/filter_s.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>filter_s : ('a -&gt; bool <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'a <a href="index.html#/t.typ">t</a></div><div class="doc"><code>filter f st</code> keeps only value <code>x</code> such that <code>f x</code> is <code>true</code></div></div></div><div class="region" id="/filter_map.val"><a href="#/filter_map.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>filter_map : ('a -&gt; 'b option) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'b <a href="index.html#/t.typ">t</a></div><div class="doc"></div></div></div><div class="region" id="/filter_map_s.val"><a href="#/filter_map_s.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>filter_map_s : ('a -&gt; 'b option <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'b <a href="index.html#/t.typ">t</a></div><div class="doc"><code>filter_map f st</code> filter and map <code>st</code> at the same time</div></div></div><div class="region" id="/map_list.val"><a href="#/map_list.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>map_list : ('a -&gt; 'b list) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'b <a href="index.html#/t.typ">t</a></div><div class="doc"></div></div></div><div class="region" id="/map_list_s.val"><a href="#/map_list_s.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>map_list_s : ('a -&gt; 'b list <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'b <a href="index.html#/t.typ">t</a></div><div class="doc"><code>map_list f st</code> applies <code>f</code> on each element of <code>st</code> and flattens
the lists returned</div></div></div><div class="region" id="/fold.val"><a href="#/fold.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>fold : ('a -&gt; 'b -&gt; 'b) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'b -&gt; 'b <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/fold_s.val"><a href="#/fold_s.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>fold_s : ('a -&gt; 'b -&gt; 'b <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'b -&gt; 'b <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>fold f s x</code> fold_like function for streams.</div></div></div><div class="region" id="/iter.val"><a href="#/iter.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>iter : ('a -&gt; unit) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/iter_p.val"><a href="#/iter_p.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>iter_p : ('a -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/iter_s.val"><a href="#/iter_s.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>iter_s : ('a -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; unit <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>iter f s</code> iterates over all elements of the stream</div></div></div><div class="region" id="/find.val"><a href="#/find.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>find : ('a -&gt; bool) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'a option <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/find_s.val"><a href="#/find_s.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>find_s : ('a -&gt; bool <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'a option <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>find f s</code> find an element in a stream.</div></div></div><div class="region" id="/find_map.val"><a href="#/find_map.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>find_map : ('a -&gt; 'b option) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'b option <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"></div></div></div><div class="region" id="/find_map_s.val"><a href="#/find_map_s.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>find_map_s : ('a -&gt; 'b option <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'b option <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>find f s</code> find and map at the same time.</div></div></div><div class="region" id="/combine.val"><a href="#/combine.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>combine : 'a <a href="index.html#/t.typ">t</a> -&gt; 'b <a href="index.html#/t.typ">t</a> -&gt; ('a * 'b) <a href="index.html#/t.typ">t</a></div><div class="doc"><code>combine s1 s2</code> combine two streams. The stream will ends when
the first stream ends.</div></div></div><div class="region" id="/append.val"><a href="#/append.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>append : 'a <a href="index.html#/t.typ">t</a> -&gt; 'a <a href="index.html#/t.typ">t</a> -&gt; 'a <a href="index.html#/t.typ">t</a></div><div class="doc"><code>append s1 s2</code> returns a stream which returns all elements of
<code>s1</code>, then all elements of <code>s2</code></div></div></div><div class="region" id="/concat.val"><a href="#/concat.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>concat : 'a <a href="index.html#/t.typ">t</a> <a href="index.html#/t.typ">t</a> -&gt; 'a <a href="index.html#/t.typ">t</a></div><div class="doc"><code>concat st</code> returns the concatenation of all streams of <code>st</code>.</div></div></div><div class="region" id="/flatten.val"><a href="#/flatten.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>flatten : 'a list <a href="index.html#/t.typ">t</a> -&gt; 'a <a href="index.html#/t.typ">t</a></div><div class="doc"><code>flatten st = map_list (fun l -&gt; l) st</code></div></div></div><div class="region" id="/result.typ"><a href="#/result.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>'a result = <table><tr class="cons"><td><div class="region" id="/result.typ/Value.cons"><a href="#/result.typ/Value.cons" class="anchor"></a>| Value of 'a</div></td></tr><tr class="cons"><td><div class="region" id="/result.typ/Error.cons"><a href="#/result.typ/Error.cons" class="anchor"></a>| Error of exn</div></td></tr></table></div><div class="doc">A value or an error.</div></div></div><div class="region" id="/map_exn.val"><a href="#/map_exn.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>map_exn : 'a <a href="index.html#/t.typ">t</a> -&gt; 'a <a href="index.html#/result.typ">result</a> <a href="index.html#/t.typ">t</a></div><div class="doc"><code>map_exn s</code> returns a stream that captures all exceptions raised
by the source of the stream (the function passed to from).<br/>Note that for push-streams (as returned by create) all
elements of the mapped streams are values.</div></div></div><div class="doc"><h2>Parsing</h2></div><div class="region" id="/parse.val"><a href="#/parse.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>parse : 'a <a href="index.html#/t.typ">t</a> -&gt; ('a <a href="index.html#/t.typ">t</a> -&gt; 'b <a href="../Lwt/index.html#/t.typ">Lwt.t</a>) -&gt; 'b <a href="../Lwt/index.html#/t.typ">Lwt.t</a></div><div class="doc"><code>parse st f</code> parses <code>st</code> with <code>f</code>. If <code>f</code> raise an exception,
<code>st</code> is restored to its previous state.<br/>It raises <code>Invalid_argument</code> if <code>st</code> is a bounded
push-stream.</div></div></div><div class="doc"><h2>Misc</h2></div><div class="region" id="/hexdump.val"><a href="#/hexdump.val" class="anchor"></a><div class="val"><div class="def"><span class="keyword">val </span>hexdump : char <a href="index.html#/t.typ">t</a> -&gt; string <a href="index.html#/t.typ">t</a></div><div class="doc"><code>hexdump byte_stream</code> returns a stream which is the same as the
output of <code>hexdump -C</code>.<br/>Basically, here is a simple implementation of <code>hexdump -C</code>:<br/><pre>
        let () = Lwt_main.run (Lwt_io.write_lines Lwt_io.stdout (Lwt_stream.hexdump (Lwt_io.read_lines Lwt_io.stdin)))
      </pre></div></div></div></div></div></div></body></html>