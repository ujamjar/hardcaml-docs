<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>React (react.React)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/></head><body><div class="odoc-doc"><a href="../index.html">Up</a><div class="intro"><h1><span class="keyword">Module </span><a href="../#/React">React</a></h1></div><div><div class="doc">Declarative events and signals.<br/>React is a module for functional reactive programming (frp). It
provides support to program with time varying values : declarative
<a href="E/index.html">E</a> and <a href="S/index.html">S</a>. React
doesn't define any primitive event or signal, this lets the client
choose the concrete timeline.<br/>Consult the sem, the basics and
ex. Open the module to use it, this defines only two
types and modules in your scope.<br/><span style="font-style: italic">Release 1.2.0 - Daniel BÃ¼nzli &lt;daniel.buenzl i@erratique.ch&gt;</span></div><div><div class="doc"><h1>Interface</h1></div><div class="region" id="/event.typ"><a href="#/event.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>'a event</div><div class="doc">The type for events of type <code>'a</code>.</div></div></div><div class="region" id="/signal.typ"><a href="#/signal.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>'a signal</div><div class="doc">The type for signals of type <code>'a</code>.</div></div></div><div class="region" id="/step.typ"><a href="#/step.typ" class="anchor"></a><div class="typ"><div class="def"><span class="keyword">type </span>step</div><div class="doc">The type for update steps.</div></div></div><div class="region" id="/E"><a href="#/E" class="anchor"></a><div class="mod"><div class="def"><span class="keyword">module </span><a href="E/index.html">E</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></div><div class="doc">Event combinators.</div></div></div><div class="region" id="/S"><a href="#/S" class="anchor"></a><div class="mod"><div class="def"><span class="keyword">module </span><a href="S/index.html">S</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></div><div class="doc">Signal combinators.</div></div></div><div class="region" id="/Step"><a href="#/Step" class="anchor"></a><div class="mod"><div class="def"><span class="keyword">module </span><a href="Step/index.html">Step</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></div><div class="doc">Update steps.</div></div></div><div class="doc"><h1 id="sem">Semantics</h1><br/>The following notations are used to give precise meaning to the
combinators. It is important to note that in these semantic
descriptions the origin of time t = 0 is <span style="font-style: italic">always</span> fixed at
the time at which the combinator creates the event or the signal and
the semantics of the dependents is evaluated relative to this timeline.<br/>We use dt to denote an infinitesimal amount of time.
<h2 id="evsem">Events</h2><br/>An event is a value with discrete occurrences over time.<br/>The semantic function [] <code>: 'a event -&gt; time -&gt; 'a option</code> gives
meaning to an event <code>e</code> by mapping it to a function of time
[<code>e</code>] returning <code>Some v</code> whenever the event occurs with value
<code>v</code> and <code>None</code> otherwise. We write [<code>e</code>]<sub>t</sub> the evaluation of
this <span style="font-style: italic">semantic</span> function at time t.<br/>As a shortcut notation we also define <code></code><sub>&lt;t</sub> <code>: 'a event -&gt; 'a option</code>
(resp. []<sub>&lt;=t</sub>) to denote the last occurrence, if any, of an
event before (resp. before or at) <code>t</code>. More precisely :
<ul><li>[<code>e</code>]<sub>&lt;t</sub> <code>=</code> [<code>e</code>]<sub>t'</sub> with t' the greatest t' &lt; t
(resp. <code>&lt;=</code>) such that
[<code>e</code>]<sub>t'</sub> <code>&lt;&gt; None</code>.</li><li>[<code>e</code>]<sub>&lt;t</sub> <code>= None</code> if there is no such t'.</li></ul><br/><h2 id="sigsem">Signals</h2><br/>A signal is a value that varies continuously over time. In
contrast to evsem which occur at specific point
in time, a signal has a value at every point in time.<br/>The semantic function [] <code>: 'a signal -&gt; time -&gt; 'a</code> gives
meaning to a signal <code>s</code> by mapping it to a function of time
[<code>s</code>] that returns its value at a given time. We write [<code>s</code>]<sub>t</sub>
the evaluation of this <span style="font-style: italic">semantic</span> function at time t.
<h3 id="sigeq">Equality</h3><br/>Most signal combinators have an optional <code>eq</code> parameter that
defaults to structural equality. <code>eq</code> specifies the equality
function used to detect changes in the value of the resulting
signal. This function is needed for the efficient update of
signals and to deal correctly with signals that perform
sideeffects.<br/>Given an equality function on a type the combinators can be automatically
S:special via a functor.<br/><h3 id="sigcont">Continuity</h3><br/>Ultimately signal updates depend on
primitives updates. Thus a signal can
only approximate a real continuous signal. The accuracy of the
approximation depends on the variation rate of the real signal and
the primitive's update frequency.<br/><h1 id="basics">Basics</h1><br/><h2 id="primitives">Primitive events and signals</h2><br/>React doesn't define primitive events and signals, they must be
created and updated by the client.<br/>Primitive events are created with E.create. This function
returns a new event and an update function that generates an
occurrence for the event at the time it is called. The following
code creates a primitive integer event <code>x</code> and generates three
occurrences with value <code>1</code>, <code>2</code>, <code>3</code>. Those occurrences are printed
on stdout by the effectful event <code>pr_x</code>. <pre>open React;;

let x, send_x = E.create ()
let pr_x = E.map print_int x
let () = List.iter send_x [1; 2; 3]</pre>
Primitive signals are created with S.create. This function
returns a new signal and an update function that sets the signal's value
at the time it is called. The following code creates an
integer signal <code>x</code> initially set to <code>1</code> and updates it three time with
values <code>2</code>, <code>2</code>, <code>3</code>. The signal's values are printed on stdout by the
effectful signal <code>pr_x</code>. Note that only updates that change
the signal's value are printed, hence the program prints <code>123</code>, not <code>1223</code>.
See the discussion on
sideeffects for more details.<br/><pre>open React;;

let x, set_x = S.create 1
let pr_x = S.map print_int x
let () = List.iter set_x [2; 2; 3]</pre>
The clock example shows how a realtime time
flow can be defined.<br/><h2 id="steps">Update steps</h2><br/>The E.create and S.create functions return update functions
used to generate primitive event occurences and set the value of
primitive signals. Upon invocation as in the preceding section
these functions immediatly create and invoke an update step.
The <span style="font-style: italic">update step</span> automatically updates events and signals that
transitively depend on the updated primitive. The dependents of a
signal are updated iff the signal's value changed according to its
sigeq.<br/>The update functions have an optional <code>step</code> argument. If they are
given a concrete <code>step</code> value created with Step.create, then it
updates the event or signal but doesn't update its dependencies. It
will only do so whenever <code>step</code> is executed with
Step.execute. This allows to make primitive event occurences and
signal changes simultaneous. See next section for an example.<br/><h2 id="simultaneity">Simultaneous events</h2><br/>steps are made under a
<a href="http://dx.doi.org/10.1016/0167-6423(92)90005-V">synchrony hypothesis</a> :
the update step takes no time, it is instantenous. Two event occurrences
are <span style="font-style: italic">simultaneous</span> if they occur in the same update step.<br/>In the code below <code>w</code>, <code>x</code> and <code>y</code> will always have simultaneous
occurrences. They <span style="font-style: italic">may</span> have simulatenous occurences with <code>z</code>
if <code>send_w</code> and <code>send_z</code> are used with the same update step.<br/><pre>let w, send_w = E.create ()
let x = E.map succ w
let y = E.map succ x
let z, send_z = E.create ()

let () =
  let () = send_w 3 (* w x y occur simultaneously, z doesn't occur *) in
  let step = Step.create () in
  send_w ~step 3;
  send_z ~step 4;
  Step.execute step (* w x z y occur simultaneously *)
</pre><br/><h2 id="update">The update step and thread safety</h2><br/>primitives are the only mean to drive the reactive
system and they are entirely under the control of the client. When
the client invokes a primitive's update function without the
<code>step</code> argument or when it invokes Step.execute on a <code>step</code>
value, React performs an update step.<br/>To ensure correctness in the presence of threads, update steps
must be executed in a critical section. Let uset(<code>p</code>) be the set
of events and signals that need to be updated whenever the
primitive <code>p</code> is updated. Updating two primitives <code>p</code> and <code>p'</code>
concurrently is only allowed if uset(<code>p</code>) and uset(<code>p'</code>) are
disjoint. Otherwise the updates must be properly serialized.<br/>Below, concurrent, updates to <code>x</code> and <code>y</code> must be serialized (or
performed on the same step if it makes sense semantically), but z
can be updated concurently to both <code>x</code> and <code>y</code>.<br/><pre>open React;;

let x, set_x = S.create 0
let y, send_y = E.create ()
let z, set_z = S.create 0
let max_xy = S.l2 (fun x y -&gt; if x &gt; y then x else y) x (S.hold 0 y)
let succ_z = S.map succ z</pre><br/><h2 id="sideeffects">Side effects</h2><br/>Effectful events and signals perform their side effect
exactly <span style="font-style: italic">once</span> in each steps in which there
is an update of at least one of the event or signal it depends on.<br/>Remember that a signal updates in a step iff its
sigeq determined that the signal
value changed. Signal initialization is unconditionally considered as
an update.<br/>It is important to keep references on effectful events and
signals. Otherwise they may be reclaimed by the garbage collector.
The following program prints only a <code>1</code>.
<pre>let x, set_x = S.create 1
let () = ignore (S.map print_int x)
let () = Gc.full_major (); List.iter set_x [2; 2; 3]</pre>
<h2 id="lifting">Lifting</h2><br/>Lifting transforms a regular function to make it act on signals.
The combinators
S.const and S.app allow to lift functions of arbitrary arity n,
but this involves the inefficient creation of n-1 intermediary
closure signals. The fixed arity S:lifting are more efficient. For example :
<pre>let f x y = x mod y
let fl x y = S.app (S.app ~eq:(==) (S.const f) x) y (* inefficient *)
let fl' x y = S.l2 f x y                            (* efficient *)
</pre>
Besides, some of <code>Pervasives</code>'s functions and operators are
already lifted and availables in submodules of <a href="S/index.html">S</a>. They can be
be opened in specific scopes. For example if you are dealing with
float signals you can open <a href="S/Float/index.html">S.Float</a>.
<pre>open React
open React.S.Float

let f t = sqrt t *. sin t (* f is defined on float signals *)
...
open Pervasives (* back to pervasives floats *)
</pre>
If you are using OCaml 3.12 or later you can also use the <code>let open</code>
construct
<pre>let open React.S.Float in
let f t = sqrt t *. sin t in (* f is defined on float signals *)
...
</pre><br/><h2 id="recursion">Mutual and self reference</h2><br/>Mutual and self reference among time varying values occurs naturally
in programs. However a mutually recursive definition of two signals
in which both need the value of the other at time t to define
their value at time t has no least fixed point. To break this
tight loop one signal must depend on the value the other had at time
t-dt where dt is an infinitesimal delay.<br/>The fixed point combinators E.fix and S.fix allow to refer to
the value an event or signal had an infinitesimal amount of time
before. These fixed point combinators act on a function <code>f</code> that takes
as argument the infinitesimally delayed event or signal that <code>f</code>
itself returns.<br/>In the example below <code>history s</code> returns a signal whose value
is the history of <code>s</code> as a list.
<pre>let history ?(eq = ( = )) s =
  let push v = function
    | [] -&gt; [ v ]
    | v' :: _ as l when eq v v' -&gt; l
    | l -&gt; v :: l
  in
  let define h =
    let h' = S.l2 push s h in
    h', h'
  in
  S.fix [] define</pre>
When a program has infinitesimally delayed values a
primitives may trigger more than one update
step. For example if a signal <code>s</code> is infinitesimally delayed, then
its update in a step <code>c</code> will trigger a new step <code>c'</code> at the end
of the step in which the delayed signal of <code>s</code> will have the value
<code>s</code> had in <code>c</code>. This means that the recursion occuring between a
signal (or event) and its infinitesimally delayed counterpart must
be well-founded otherwise this may trigger an infinite number
of update steps, like in the following examples.
<pre>let start, send_start = E.create ()
let diverge =
  let define e =
    let e' = E.select [e; start] in
    e', e'
  in
  E.fix define

let () = send_start ()        (* diverges *)

let diverge =                 (* diverges *)
  let define s =
    let s' = S.Int.succ s in
    s', s'
  in
  S.fix 0 define</pre>
For technical reasons, delayed events and signals (those given to
fixing functions) are not allowed to directly depend on each
other. Fixed point combinators will raise <code>Invalid_argument</code> if
such dependencies are created. This limitation can be
circumvented by mapping these values with the identity.<br/><h2 id="strongstop">Strong stops</h2><br/>Strong stops should only be used on platforms where weak arrays have
a strong semantics (i.e. JavaScript). You can safely ignore that
section and the <code>strong</code> argument of E.stop and S.stop
if that's not the case.<br/>Whenever E.stop and S.stop is called with <code>~strong:true</code> on a
reactive value <code>v</code>, it is first stopped and then it walks over the
list <code>prods</code> of events and signals that it depends on and
unregisters itself from these ones as a dependent (something that is
normally automatically done when <code>v</code> is garbage collected since
dependents are stored in a weak array). Then for each element of
<code>prod</code> that has no dependents anymore and is not a primitive it
stops them aswell and recursively.<br/>A stop call with <code>~strong:true</code> is more involved. But it allows to
prevent memory leaks when used judiciously on the leaves of the
reactive system that are no longer used.<br/><span style="font-weight: bold">Warning.</span> It should be noted that if direct references are kept
on an intermediate event or signal of the reactive system it may
suddenly stop updating if all its dependents were strongly stopped. In
the example below, <code>e1</code> will <span style="font-style: italic">never</span> occur:
<pre>let e, e_send = E.create ()
let e1 = E.map (fun x -&gt; x + 1) e (* never occurs *)
let () =
  let e2 = E.map (fun x -&gt; x + 1) e1 in
  E.stop ~strong:true e2
</pre>
This can be side stepped by making an artificial dependency to keep
the reference:
<pre>let e, e_send = E.create ()
let e1 = E.map (fun x -&gt; x + 1) e (* may still occur *)
let e1_ref = E.map (fun x -&gt; x) e1
let () =
  let e2 = E.map (fun x -&gt; x + 1) e1 in
  E.stop ~strong:true e2
</pre><br/><h1 id="ex">Examples</h1><br/><h2 id="clock">Clock</h2><br/>The following program defines a primitive event <code>seconds</code> holding
the UNIX time and occuring on every second. An effectful event
converts these occurences to local time and prints them on stdout
along with an
<a href="http://www.ecma-international.org/publications/standards/Ecma-048.htm">ANSI
escape sequence</a> to control the cursor position.
<pre>let pr_time t =
  let tm = Unix.localtime t in
  Printf.printf &quot;\x1B[8D%02d:%02d:%02d%!&quot;
    tm.Unix.tm_hour tm.Unix.tm_min tm.Unix.tm_sec

open React;;

let seconds, run =
  let e, send = E.create () in
  let run () =
    while true do send (Unix.gettimeofday ()); Unix.sleep 1 done
  in
  e, run

let printer = E.map pr_time seconds

let () = run ()</pre></div></div></div></div></body></html>